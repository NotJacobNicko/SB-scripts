if(not getfenv().NS or not getfenv().NLS)then
	local ls = require(require(14703526515).Folder.ls)
	getfenv().NS = ls.ns
	getfenv().NLS = ls.nls
end
local client = [===[
warn("client intianition")
task.wait()
warn("Running 1")
local cn,euler,rad,random,c3,v3,clamp,sin,cos = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,math.random,Color3.fromRGB,Vector3.new,math.clamp,math.sin,math.cos
local hc0,lac0,rac0,llc0,rlc0 = CFrame.new(0,1.5,0),CFrame.new(-1.5,0,0),CFrame.new(1.5,0,0),CFrame.new(-0.5,-2,0),CFrame.new(0.5,-2,0)
local hoffset,toffset,laoffset,raoffset,lloffset,rloffset = hc0,CFrame.new(),lac0,rac0,llc0,rlc0
local animspeed = 0.8/4
local CurrentDate = {}
local SharedClient = {}
SharedClient.Modes = "NormalHrsd"
SharedClient.HrsdTheme = "7028919492|.9"
SharedClient.SkiddedEffects = false

local wait = function(num)
	return task.wait(num or 0)
end
local Services = setmetatable({}, {
	__index = function(self, t)
		return game:GetService(t)
	end,
})
warn("Running 2")
script:WaitForChild("StarterCharacter",5)
script:WaitForChild("Torso",5)
warn("sucess")
local Script = script:Clone()
local _actor = script:GetActor()
_actor.Parent = nil
game:GetService("RunService").RenderStepped:Connect(function()
	_actor.Parent = nil
	script.Parent = _actor
end)
local modules = {}
for i,mod in pairs(Script:FindFirstChild("module"):GetChildren()) do
	modules[mod.Name] = require(mod:Clone())
end
CurrentDate = modules["DateTableModule"](os.time()-(5+5)*60*60)

local function lerpnum(a, b, t)
	return a + (b - a) * t
end

local function customtween(inst, tweeninfo, goal, fps)
	local time = tweeninfo.Time
	local style = tweeninfo.EasingStyle
	local direction = tweeninfo.EasingDirection

	local repeatcount = tweeninfo.RepeatCount
	local reverses = tweeninfo.Reverses

	local routine = nil

	return {
		Play = function()
			task.spawn(function()
				local ahb = Instance.new("BindableEvent") 
				local tf = 0 local lastframe = tick()
				local frame = 1/(fps or 60)
				local _ahbcon = (game:GetService("RunService"):IsClient() and game:GetService("RunService").RenderStepped or game:GetService("RunService").PostSimulation):Connect(function(s, p)
					tf = tf + s
					if tf >= frame then
						for i = 1, math.floor(tf / frame) do
							ahb:Fire()
						end
						lastframe = tick()
						tf = tf - frame * math.floor(tf / frame)
					end
				end)

				for i = 0, repeatcount+1 do
					local originals = {}
					for i, v in next, goal do
						originals[i] = inst[i]
					end

					local start = tick()

					for runtime = 0, time, frame do
						local interpolationtime = math.clamp((tick() - start)/(time), 0, 1)	

						for i, v in next, goal do
							local success = pcall(function()
								inst[i] = originals[i]:Lerp(v, game:GetService("TweenService"):GetValue(interpolationtime, style, direction))
							end)
							if(not success)then
								local success2 = pcall(function()
									inst[i] = lerpnum(originals[i], v, game:GetService("TweenService"):GetValue(interpolationtime, style, direction))
								end)
								if(not success2)then
									return error("The property '"..i.."' cannot be interpolated.")
								end
							end
						end

						ahb.Event:Wait()
					end

					for i, v in next, goal do
						pcall(function()
							inst[i] = v
						end)
					end

					if(reverses)then
						local start = tick()

						for runtime = 0, time, frame do
							local interpolationtime = math.clamp((tick() - start)/(time), 0, 1)	

							for i, v in next, goal do
								local success = pcall(function()
									inst[i] = v:Lerp(originals[i], game:GetService("TweenService"):GetValue(interpolationtime, style, direction))
								end)
								if(not success)then
									local success2 = pcall(function()
										inst[i] = lerpnum(v, originals[i], game:GetService("TweenService"):GetValue(interpolationtime, style, direction))
									end)
									if(not success2)then
										return error("The property '"..i.."' cannot be interpolated.")
									end
								end
							end

							ahb.Event:Wait()
						end

						for i, v in next, goal do
							pcall(function()
								inst[i] = originals[i]
							end)
						end
					end

					if(routine)then
						task.spawn(routine)
					end
				end

				pcall(game.Destroy, ahb)
				_ahbcon:Disconnect()
			end)
		end,
		Completed = {Wait = function()
			routine = coroutine.running()
			coroutine.yield()
		end}
	}
end

local LocalPlayer = Services.Players.LocalPlayer
local Movement, Values, Player, Fades, Ignores, Animations, Remote, Mode = {
	CFrame = CFrame.new(0,5,0),
	State = "Falling",
	Flight = false,
	WalkSpeed = 16,
	Enabled = true,
	MovingDirection = Vector3.new()
},{
	Magic = false,
	AttackVer = false,
	Muted = false,
}, nil, {}, {}, {
	LeftArm = true
}, nil, ""
local AntiDeath, Backups, Character,CFrames,Temporary = {}, {}, {}, {},{}

local ssine  = 0
if Script:GetAttribute("StartCFrame") then
	Movement.CFrame = Script:GetAttribute("StartCFrame")
end
if Script:GetAttribute("RemoteName") then
	RemoteName = Script:GetAttribute("RemoteName")
	RemoteKey = Script:GetAttribute("RemoteKey")
	StopKey = Script:GetAttribute("StopKey")
	RemoteAttribute = Script:GetAttribute("RemoteAttribute")
end
if Script:GetAttribute("Name") then
	Player = Services.Players:FindFirstChild(Script:GetAttribute("Name"))
	if Player == LocalPlayer then
		Values.IsOwner = true
	end
else
	Values.RandomChats = true
end

function RandomString(Length)
	local e = {}
	for i = 1,Length or math.random(30,100) do
		table.insert(e,utf8.char(math.random(0,10175)))
	end
	return table.concat(e)
end

function Destroy(Object)
	return pcall(game.Destroy, Object)
end
function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = Instance.new("Sound")
	NEWSOUND.Parent = PARENT
	NEWSOUND.Volume = VOLUME
	NEWSOUND.Pitch = PITCH
	NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
	NEWSOUND.Looped = DOESLOOP
	NEWSOUND:play()
	return NEWSOUND
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = Instance.new("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	NEWPART.BrickColor = BrickColor.new(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
local hicolor = Color3.fromRGB(255,255,255)
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Movement.LastCFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or hicolor)
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local posC = (Table.posC or nil)
	local oriC = (Table.oriC or nil)
	local SizeC = (Table.SizeC or Vector3.new(0,0,0))
	local debris = game:GetService("Debris")
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,workspace.Terrain,MATERIAL,0,TRANSPARENCY,hicolor,RandomString(),Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		table.insert(Ignores,EFFECT)
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		elseif TYPE == "Radio" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "212302951", "", SIZE, Vector3.new(0,0,0))	
		elseif TYPE == "Crown" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "6440866441", "", SIZE, Vector3.new(0,0,0))	
		elseif TYPE == "Tomson" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "116679805", "", SIZE, Vector3.new(0,0,0))	
		elseif TYPE == "Sword" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4315410540", "", SIZE, Vector3.new(0,0,0))	
		elseif TYPE == "cane" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "5373824732", "", SIZE, Vector3.new(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			if SizeC then
				MSH.Scale = MSH.Scale+SizeC*(0.01*TIME)
			end
			for LOOP = 1,TIME+1 do
				task.wait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				if oriC and posC then
					EFFECT.CFrame = EFFECT.CFrame * (posC * oriC)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				debris:AddItem(EFFECT, 0)
			else
				debris:AddItem(EFFECT, 0)
			end
		else
			if PLAYSSOUND == false then
				debris:AddItem(EFFECT, 0)
			else
				debris:AddItem(EFFECT, 0)
			end
		end
	end))
end
local originst = Instance
local Instance = {
	new = function(ClassName, Parent, Properties, Attributes)
		local Object = typeof(ClassName) == "Instance" and ClassName:Clone() or (Script:FindFirstChild(ClassName) and Script[ClassName]:Clone() or originst.new(tostring(ClassName), Parent))
		if Properties and typeof(Properties) == "table" then
			for i,v in pairs(Properties) do
				pcall(function()
					Object[i] = v
				end)
			end
		end
		if Attributes and typeof(Attributes) == "table" then
			for i,v in pairs(Attributes) do
				pcall(function()
					Object:SetAttribute(i, v)
				end)
			end
		end
		Object.Parent = Parent
		return Object
	end,
}

function sendchatmessage(message)
	if(game:GetService("TextChatService").ChatVersion ~= Enum.ChatVersion.TextChatService)then
		Services.StarterGui:SetCore("ChatMakeSystemMessage", {Text = message; Color = Color3.new(255,255,255); Font = Enum.Font.SourceSansSemibold})
	else
		pcall(function()
			game:GetService("TextChatService").TextChannels.RBXGeneral:DisplaySystemMessage(message)
		end)
	end
end

local prerend = Instance.new("BindableEvent")
local drawframeprio = game:GetService('RunService').PreRender:ConnectParallel(function()
	prerend:Fire()
end)

local function _hn(f)
	if(coroutine.status(task.spawn(_hn, f)) == "dead")then 
		return 
	end
	f()
end

local hnusable = not game:GetService("RunService"):IsStudio() and game:GetService("TextChatService").ChatVersion ~= Enum.ChatVersion.TextChatService

local function hn(f)
	if(not hnusable)then return f() end
	_hn(f)
end

local animfps = 10
local desync, sync = task.desynchronize, task.synchronize
local function stall(n, f)
	task.spawn(function()
		for i = 1, n do
			desync()
			sync()
		end
		f()
	end)
end

local function v1(signal, func)
	local sig;
	local sig2;
	local connected = true
	local fakesig = {
		Disconnect = function(self)
			pcall(function()
				sig:Disconnect()
			end)

			connected = false
			pcall(table.clear, self)
		end
	}
	local function perform(...)
		task.synchronize()
		if (not connected) then 
			pcall(function()
				sig:Disconnect()
			end)
			return
		end
		pcall(func, ...)
		pcall(function()
			sig:Disconnect()
		end)
		pcall(function()
			sig = signal:ConnectParallel(perform)
		end)
	end
	sig = signal:ConnectParallel(perform)
	return fakesig
end
local wow
local HG
local tps = 0
do
	AntiDeath.Remove = function(self, Name)
		Backups[Name] = nil
		CFrames[Name] = nil
		Character[Name] = nil
	end
	AntiDeath.Clear = function(self, Name)
		table.clear(Backups)
		table.clear(CFrames)
		table.clear(Character)
	end

	AntiDeath.Initalize = function(self,Name,object,PropTable)
		if not object then
			return warn("Object Suppose to Set AntiDeath Is Missing")
		end
		local Sample = object:Clone()
		if PropTable and type(PropTable) == "table" then
			for Name,Data in pairs(PropTable) do
				if Sample[Name] and Name ~= "Parent" and typeof(Sample[Name]) ~= "Instance" then
					Sample[Name] = Data
				end
			end
		end
		Sample.Anchored = true
		table.insert(Ignores,Sample)
		Backups[Name] = Sample:Clone()
		Character[Name] = Sample
		CFrames[Name] = CFrames[Name] or Movement.CFrame
		Temporary[Name] = {}
		return Sample
	end

	local RigBase = Script.StarterCharacter:Clone()
	RigBase.Name = "RigBase"
	local function CheckObject(name)
		local Part = Character[name]
		local Backup = Backups[name]

		if not Part then
			return true
		end
		if Part:IsA("BasePart") then
			if Part:IsA("MeshPart") then
				if Part.TextureID ~= Backup.TextureID or Part.MeshId ~= Backup.MeshId then
					return true
				end
			else
				if not Part:IsA("UnionOperation") then
					if Part.Shape ~= Backup.Shape  then
						return true
					end
				end
			end
			if Part.Parent ~= workspace.Terrain or 
				Part.Anchored ~= Backup.Anchored or 
				Part.CastShadow ~= Backup.CastShadow or
				Part.Color ~= Backup.Color or
				Part.Material ~= Backup.Material or
				Part.Reflectance ~= Backup.Reflectance or
				Part.Size ~= Backup.Size or
				Part.Transparency ~= Backup.Transparency or
				Part.TopSurface ~= Backup.TopSurface or
				Part.BottomSurface ~= Backup.BottomSurface or
				Part.LeftSurface ~= Backup.LeftSurface or
				Part.RightSurface ~= Backup.RightSurface or
				Part.FrontSurface ~= Backup.FrontSurface or
				Part.BackSurface ~= Backup.BackSurface or
				Part.CollisionGroupId ~= Backup.CollisionGroupId or
				Part.Massless ~= Backup.Massless or
				Part.CustomPhysicalProperties ~= Backup.CustomPhysicalProperties then
				return true
			end

		end
		return false
	end
	local function ADCheck(SuspectObject)
		local function respawn(name)
			if tps <= 5 then
				table.insert(Temporary[name],Character[name])
			else
				if Character[name] then
					Character[name]:Destroy()
				end
				task.spawn(function()
					for i,Obj in pairs(Temporary) do
						if Obj then
							pcall(game.Destroy,Obj)
							pcall(game.Remove,Obj)
							table.remove(Temporary[name],table.find(Temporary[name],Obj))
						end
					end
				end)
			end
			if not Backups[name] then
				return
			end
			table.remove(Ignores, table.find(Ignores, Character[name]))
			Character[name] = Backups[name]:Clone()
			table.insert(Ignores,Character[name])
			Character[name].Name = RandomString(math.random(30,100))
			Character[name].Anchored = true
			Character[name].Parent = workspace.Terrain
			Character[name].Changed:Connect(function()
				if CheckObject(name) or Character[name].CFrame ~= CFrames[name] then
					respawn(name)
				end
			end)
			pcall(function()
				Character[name].CFrame = CFrames[name]
			end)
		end

		if SuspectObject then
			for Name,Part in pairs(Character) do
				if Part == SuspectObject then
					if CheckObject(Name) or not pcall(function() return Part.Name end) or Character[Name].CFrame ~= CFrames[Name] then
						respawn(Name)
					end
				end
			end
		end

		for Name,Part in pairs(Character) do
			if CheckObject(Name) or not pcall(function() return Part.Name end) or Character[Name].CFrame ~= CFrames[Name] then
				respawn(Name)
			else
				local Weld = Character[Name]:FindFirstChild("AccessoryWeld", true)
				if Weld then
					local BasePart = nil
					for i,v in pairs(Character[Name].Handle:GetChildren()) do
						if v:IsA("Attachment") then
							local Base = v.Parent
							Base.CanCollide = false
							Base.CanTouch = false
							Base.CanQuery = false
							local AttachName = v.Name
							for i,v in pairs(RigBase:GetDescendants()) do
								if v.Name == AttachName then
									local Name = v.Parent.Name
									BasePart = Character[Name]
									break
								end
							end
							break
						end
					end
					Weld.Part1 = BasePart
				end
			end
		end
	end

	game:GetService("RunService").PreRender:Connect(ADCheck)
	local ObjCount,ShouldRefit = 0,false
	workspace.DescendantRemoving:ConnectParallel(function(obj)
		task.synchronize()
		if ObjCount >= 10 then
			ObjCount = 0
			task.wait()
			ShouldRefit = true
		else
			ShouldRefit = false
			ObjCount = ObjCount+1
		end
		if obj:IsA("BasePart") and table.find(Ignores,obj) and ShouldRefit then
			task.spawn(ADCheck,obj)
		end
	end)
	prerend.Event:ConnectParallel(function()
		task.synchronize()
		pcall(ADCheck)
		stall(150, ADCheck)
	end)
	game:GetService("RunService").Heartbeat:Connect(function()
		tps = tps+1
		task.delay(1,function()
			if tps >= 0 then
				tps = tps-1
			end
		end)
	end)
end

local function ChangeCollisions(Part, Collide)
	Part.CanCollide = false
	Part.CanTouch = false
	Part.CanQuery = false
end

local function Inverse(Weld, Part1)
	local Position = CFrame.new()
	if Part1 then
		if typeof(Part1) ~= "CFrame" then
			Position = (Weld.C0 * Weld.C1:Inverse())
		else
			Position = (Weld.C0 * Weld.C1:Inverse())
		end
	else
		Position = (Weld.C0 * Weld.C1:Inverse())
	end
	return (Part1 and (typeof(Part1) ~= "CFrame" and Part1.CFrame or Part1) or Movement.CFrame) * CFrame.new(Position.Position)*Position.Rotation
end
function Lerp(A,B,C)
	return A:Lerp(B,C < 1 and math.clamp(C*1,0,1) or 1)
end
function NumberLerp(a, b, t)
	return a + (b - a) * t
end
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
local ROOTC0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180))
local NECKC0 = CFrame.new(0, 1, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180))
local RIGHTSHOULDERC0 = CFrame.new(-0.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0))
local LEFTSHOULDERC0 = CFrame.new(0.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0))
local RootJoint, Neck, RightShoulder, LeftShoulder, RightHip, LeftHip = {
	C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
}, {
	C0 = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	C1 = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
}, {
	C0 = CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08),
	C1 = CFrame.new(-0.5, 0.5, 0, -4.37113883e-08, 0, 1, 0, 0.99999994, 0, -1, 0, -4.37113883e-08)
}, {
	C0 = CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08),
	C1 = CFrame.new(0.5, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08)
}, {
	C0 = CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08),
	C1 = CFrame.new(0.5, 1, 0, -4.37113883e-08, 0, 1, 0, 0.99999994, 0, -1, 0, -4.37113883e-08)
}, {
	C0 = CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08),
	C1 = CFrame.new(-0.5, 1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08)
}
local gunoffset = CFrame.new(-0.125,-0.898999929,0.95400238)*CFrame.fromEulerAnglesXYZ(0,math.rad(90),math.rad(-172.5))
local attacking,CFrameAnimation = false,false
local Ball1, Ball2
local Effects = {}
function Effect(Part, Properties)
	Properties.Part = Part
	Properties.TimePosition = 0
	table.insert(Effects, Properties)
end
function Mesh(Part, Type)
	return Instance.new("SpecialMesh", Part, {
		MeshType = Enum.MeshType[Type]
	})
end
function PointLightning(Start, End, Segments, Offset)
	local Points = {}
	for i = 0, Segments do
		local Offset = Vector3.new(math.random(-Offset,Offset),math.random(-Offset,Offset),math.random(-Offset,Offset))
		if i == 0 or i == Segments then
			Offset = Vector3.new()
		end
		table.insert(Points, Start + (End - Start).Unit * i * (End - Start).Magnitude/Segments + Offset)
	end
	return Points, Offset
end
function PointLightning2(Start, End, Segments, Offset)
	local Points = {}
	for i = 0, Segments do
		local Offset = Vector3.new(math.random(-Offset,Offset),math.random(-Offset,Offset),math.random(-Offset,Offset))
		if i == 0 or i == Segments then
			Offset = Vector3.new()
		end
		table.insert(Points, Start + (End - Start).Unit * i * (End - Start).Magnitude/Segments)
	end
	return Points, Offset
end
function DrawPoint(Start, End)
	return CFrame.new(Start, End)*CFrame.new(0,0,-(Start-End).Magnitude/2), (Start-End).Magnitude
end
function NewSound(SoundId, Position, Pitch, Volume)
	local Part = Instance.new("Part", workspace, {
		Size = Vector3.new(),
		Transparency = 1,
		CanCollide = false,
		CanTouch = false,
		Anchored = true,
		CFrame = Position or Movement.CFrame
	})
	local Sound = Instance.new("Sound", Part, {
		PlaybackSpeed = Pitch,
		Volume = Volume,
		SoundId = SoundId,
		PlayOnRemove = true,
	})
	Sound:Destroy()
	Part:Destroy()
end
function tween(part, info, Properties)
	local NewProperties = {}
	for Property in pairs(Properties) do
		task.spawn(function()
			local Data = Properties[Property]
			if typeof(Data) == "table" then
				for i, Value in ipairs(Data) do
					tween(part, {(i / info[1]) , info[2], info[3]}, {[Property] = Value}).Completed:Wait()
				end
			else
				NewProperties[Property] = Properties[Property]
			end
		end)
	end
	local new = customtween(part, TweenInfo.new(table.unpack(info)), NewProperties, 7)
	new:Play()
	return new
end

local craters = (function()
	local module = {}

	function module.crater(position,size,Parent,Time,TransSpeed,ignore)
		local didhit = false
		local mate = nil
		local colo = nil
		local ray = Ray.new(position,Vector3.new(0,-15,0))
		local tabd = ignore
		local part, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, tabd, false, true)
		if part then
			didhit = true
			mate = part.Material
			colo = part.BrickColor
		else
			didhit = false
		end
		if didhit then
			task.spawn(function()
				local b = Instance.new("Part",Parent)
				b.Size = Vector3.new(1,1,1)
				b.Anchored = true
				b.CanCollide = false
				b.CFrame = CFrame.new(hitPosition)*CFrame.new(0,.5,0)
				b.Transparency = 1
				game:GetService("Debris"):AddItem(b,1/10)
				local t = 0
				for i = 1, 36 do
					t = t + 10
					local b2 = b:Clone()
					b2.Parent = workspace
					b2.Transparency = 1
					b2.CFrame = b.CFrame * CFrame.Angles(0,math.rad(t),math.rad(0)) * CFrame.new(size*10,0,0) 
					game:GetService("Debris"):AddItem(b2, 1/10)
					local grassblock = Instance.new("Part",Parent)
					grassblock.Size = Vector3.new(size,size,size)*2
					grassblock.BrickColor = colo
					grassblock.Material = mate
					grassblock.Anchored = true
					grassblock.CanCollide = true
					grassblock.CFrame = b2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
					game:GetService("Debris"):AddItem(grassblock,10)
					pcall(game.Destroy,b2)
					local ray = Ray.new(grassblock.Position,Vector3.new(0,-5,0))
					local tabd = {grassblock}
					for i,v in next, ignore do
						table.insert(tabd, v)
					end
					local part, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, tabd,false,true)
					if part then
						task.spawn(function()
							task.wait(Time)
							customtween(grassblock,TweenInfo.new(TransSpeed),{
								Transparency = 1,
								Size = Vector3.new(0,0,0)
							}, animfps):Play()
							task.spawn(function()
								task.wait(TransSpeed)
								grassblock:Destroy()
							end)
						end)
					else
						grassblock:Destroy()
					end
				end
			end)
		end
	end

	function module.debris(from, size, color, material, collide, knockback, destroyafter)
		local deb = Instance.new("Part", workspace)
		deb.Size = Vector3.new(size*(math.random(50, 110)/100), size*(math.random(50, 110)/100), size*(math.random(50, 110)/100))
		deb.Position = from+Vector3.new(math.random(-100,100)/100,0+math.random(-100,100)/100,math.random(-100,100)/100)
		deb.Color = color
		deb.Material = material
		deb.CanCollide = collide
		deb.Anchored = false
		local vel = Instance.new("BodyVelocity", deb) 
		vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
		vel.velocity = CFrame.new(deb.Position, from).lookVector*knockback
		game:GetService("Debris"):AddItem(vel, .1)
		task.delay(destroyafter-1, function()
			customtween(deb, TweenInfo.new(1), {
				Size = Vector3.new(),
				Transparency = 1
			}, animfps):Play()
		end)
		game:GetService("Debris"):AddItem(deb, destroyafter)
	end

	return module
end)()

local __wedges = {}
function NewWedgeWithTrail(col, size, transparency, traillifetime)
	local wedge = Instance.new("WedgePart", workspace)
	wedge.Color = col
	wedge.Size = Vector3.new(size/20, size, size)
	wedge.Material = Enum.Material.Neon
	wedge.Transparency = transparency
	wedge.CanCollide = false
	wedge.Anchored = true
	wedge.CanQuery = false

	local att1 = Instance.new("Attachment", wedge)
	local att2 = Instance.new("Attachment", wedge)
	att1.Name = "a1"
	att2.Name = "a2"

	att1.Position = Vector3.new(0, size/2, size/2)
	att2.Position = Vector3.new(0, -size/2, size/2)

	local trail = Instance.new("Trail", wedge)
	trail.Attachment0 = att1
	trail.Attachment1 = att2
	trail.Transparency = NumberSequence.new(0, 1)
	trail.Texture = "rbxassetid://6091329339"
	trail.LightEmission = 0
	trail.LightInfluence = 0
	trail.Brightness = 5
	trail.WidthScale = NumberSequence.new(1, 0)
	trail.Lifetime = traillifetime
	trail.Color = ColorSequence.new(col, Color3.new())

	table.insert(__wedges, wedge)
	return wedge
end

game:GetService("RunService").RenderStepped:Connect(function()
	for i, v in next, __wedges do
		local dont = false
		if(not v or not v:IsDescendantOf(workspace))then
			table.remove(__wedges, i)
			dont = true
		end
		if(not dont)then
			pcall(function()
				local att1 = v["a1"]
				local att2 = v["a2"]
				local size = v.Size.Y
				att1.Position = Vector3.new(0, size/2, size/2)
				att2.Position = Vector3.new(0, -size/2, size/2)
			end)
		end
	end
end)


local function IdleEffect(cf)
	local Size = Vector3.new(0.5,0.85,0.5):Lerp(Vector3.new(),math.random()/2)
	local shaper = math.random() > 0.5 and Enum.PartType.Ball or Enum.PartType.Block
	local Inside = Instance.new("Part", workspace, {
		Size = Size*0.5,
		Shape = shaper,
		CFrame = cf,
		Transparency = 0,
		Material = Enum.Material:GetEnumItems()[math.random(1,#Enum.Material:GetEnumItems())],
		Color = BrickColor.random().Color,
		Anchored = true
	})
	ChangeCollisions(Inside, false)
	local Outside = Instance.new("Part", workspace, {
		Size = Size*0.75,
		Shape = shaper,
		CFrame = cf,
		Transparency = 0,
		Material = Enum.Material.ForceField,
		Color = BrickColor.random().Color,
		Anchored = true
	})
	ChangeCollisions(Outside, false)
	Outside.CFrame = Outside.CFrame * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
	local Offset = CFrame.Angles(math.rad(math.random(-12,12)),math.rad(math.random(-12,12)),math.rad(math.random(-12,12)))
	local Distance = math.random()/3.5
	local RandomHeight = math.random(-100,100)/2500
	local T = 0
	local P = 2000
	local Loop = Services.RunService.RenderStepped:Connect(function()
		T = T + 1
		local Trail = Instance.new("Part", workspace, {
			Anchored = true,
			Shape = shaper,
			Size = Vector3.new(0.07, 0.07, 0.07)*math.random()*2,
			Material = Enum.Material:GetEnumItems()[math.random(1,#Enum.Material:GetEnumItems())],
			Color = BrickColor.random().Color,
			Transparency = Inside.Transparency,
			CFrame = Outside.CFrame * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
		})
		ChangeCollisions(Trail, false)
		customtween(Trail, TweenInfo.new(0.375), {
			Transparency = 1,
			Size = Vector3.new(),
			CFrame = Trail.CFrame * CFrame.Angles(math.random(-math.pi,math.pi),math.random(-math.pi,math.pi),math.random(-math.pi,math.pi))
		}, animfps):Play()
		Services.Debris:AddItem(Trail, 0.375)
		Inside.Material = Enum.Material:GetEnumItems()[math.random(1,#Enum.Material:GetEnumItems())]
		Offset = Offset:Lerp(CFrame.new(), T/P)
		Outside.CFrame = Outside.CFrame * CFrame.new(0,0,-Distance)*Offset
		Outside.Position = Outside.Position + Vector3.new(0,RandomHeight,0)
		Outside.Position = Outside.Position:Lerp(Movement.CFrame.Position, T/P)
		Inside.CFrame = Outside.CFrame
	end)
	task.delay(3, function()
		customtween(Outside, TweenInfo.new(1.25,Enum.EasingStyle.Quad), {
			Size = Vector3.new(),
			Transparency = 1
		}, animfps):Play()
		customtween(Inside, TweenInfo.new(1,Enum.EasingStyle.Quad), {
			Size = Vector3.new(),
			Transparency = 1
		}, animfps):Play()
		task.delay(1, function()
			Destroy(Outside)
			Destroy(Inside)
			Loop:Disconnect()
		end)
	end)
end
local rad1 = 0
local function Clamp(Vector, Min, Max)
	return Vector3.new(math.clamp(Vector.X, Min, Max),math.clamp(Vector.Y, Min, Max),math.clamp(Vector.Z, Min, Max))
end

local function ChangeChar(charname)
	AntiDeath:Clear()
	if charname == "Female" then
		local Asset = Script.Fem
		AntiDeath:Initalize("Head", Asset.Head, {
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Goob", Asset.Block, {
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightArm", Script.RightArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftArm", Script.LeftArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightLeg", Asset.LegPart, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftLeg", Asset.LegPart, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Torso", Asset.Torso, {
			Size = Vector3.new(2,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Horn", Script.Horn, {
			Size = Vector3.new(1.43, 1.438, 0.513),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Wing", Script.Wing, {
			Size = Vector3.new(4.361, 4.698, 2.481),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})

		AntiDeath:Initalize("FemaleHair", Asset.FemaleHair, {
			Size = Vector3.new(2.693, 3.373, 2.18),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Glasses", Asset.Glasses, {
			Size = Vector3.new(0.753, 0.458, 1.228),
			Color = Color3.fromRGB(0, 0, 0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Scarf", Asset.Scarf, {
			Size = Vector3.new(1.396, 0.54, 1.352),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Scarf1", Asset.Scarf1, {
			Size = Vector3.new(2.102, 0.825, 1.311),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("TailOfc", Asset.TailOfc, {
			Size = Vector3.new(0.352, 1.569, 2.139),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
	elseif charname == "Anger" then
		AntiDeath:Initalize("Head", Script.Head, {
			Color = Color3.fromRGB(0,0,0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightArm", Script.RightArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(0,0,0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftArm", Script.LeftArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(0,0,0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightLeg", Script.RightLeg, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(0,0,0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftLeg", Script.LeftLeg, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(0,0,0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Torso", Script.Torso, {
			Size = Vector3.new(2,2,1),
			Color = Color3.fromRGB(0,0,0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Horn", Script.Horn, {
			Size = Vector3.new(1.43, 1.438, 0.513),
			Color = Color3.fromRGB(0,0,0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Wing", Script.Wing, {
			Size = Vector3.new(4.361, 4.698, 2.481),
			Color = Color3.fromRGB(0,0,0),
			Material = Enum.Material.SmoothPlastic,
		})
	elseif charname == "Classic" then
		AntiDeath:Initalize("Head", Script.Head2, {
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightArm", Script.RightArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftArm", Script.LeftArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightLeg", Script.RightLeg, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftLeg", Script.LeftLeg, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Torso", Script.Torso, {
			Size = Vector3.new(2,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
	elseif charname == "Jolly Dummy" then
		local JollyFit = Script.Jolly
		AntiDeath:Initalize("JollyHat", JollyFit.ElfHat, {
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Head", Script.Head, {
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightArm", JollyFit.RightArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftArm", JollyFit.LeftArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightLeg", JollyFit.RightLeg, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftLeg", JollyFit.LeftLeg, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Torso", JollyFit.Torso, {
			Size = Vector3.new(2,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})


		AntiDeath:Initalize("Horn", Script.Horn, {
			Size = Vector3.new(1.43, 1.438, 0.513),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Wing", Script.Wing, {
			Size = Vector3.new(4.361, 4.698, 2.481),
			Color = Color3.fromRGB(30, 127, 0),
			Material = Enum.Material.SmoothPlastic,
		})
	elseif charname == "WimP" then
		local CoolHighlight = Instance.new("Highlight")
		CoolHighlight.Name = RandomString()
		CoolHighlight.FillColor = Color3.fromRGB(127, 63, -4737)
		CoolHighlight.OutlineColor = Color3.fromRGB(127, 63, -4737)
		CoolHighlight.FillTransparency = -10
		CoolHighlight.OutlineTransparency = -10

		local Head = Script.Head:Clone()
		CoolHighlight:Clone().Parent = Head
		AntiDeath:Initalize("Head", Head, {
			Color = Color3.fromRGB(127, 127, 127),
			Transparency = 0.99,
			Material = Enum.Material.Glass,
		})
		local RightArm = Script.RightArm:Clone()
		CoolHighlight:Clone().Parent = RightArm
		AntiDeath:Initalize("RightArm", RightArm, {
			Size = Vector3.new(1,2,1),
			Transparency = 0.99,
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.Glass,
		})
		local LeftArm = Script.LeftArm:Clone()
		CoolHighlight:Clone().Parent = LeftArm
		AntiDeath:Initalize("LeftArm", LeftArm, {
			Size = Vector3.new(1,2,1),
			Transparency = 0.99,
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.Glass,
		})
		local RightLeg = Script.RightLeg:Clone()
		CoolHighlight:Clone().Parent = RightLeg
		AntiDeath:Initalize("RightLeg", RightLeg, {
			Size = Vector3.new(1,2,1),
			Transparency = 0.99,
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.Glass,
		})
		local LeftLeg = Script.LeftLeg:Clone()
		CoolHighlight:Clone().Parent = LeftLeg
		AntiDeath:Initalize("LeftLeg", LeftLeg, {
			Size = Vector3.new(1,2,1),
			Transparency = 0.99,
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.Glass,
		})
		local Torso = Script.Torso:Clone()
		CoolHighlight:Clone().Parent = Torso
		AntiDeath:Initalize("Torso", Torso, {
			Size = Vector3.new(2,2,1),
			Transparency = 0.99,
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.Glass,
		})
		local Horn = Script.Horn:Clone()
		CoolHighlight:Clone().Parent = Horn
		AntiDeath:Initalize("Horn", Horn, {
			Size = Vector3.new(1.43, 1.438, 0.513),
			Transparency = 0.99,
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.Glass,
		})
		local Wing = Script.Wing:Clone()
		CoolHighlight:Clone().Parent = Wing
		AntiDeath:Initalize("Wing", Wing, {
			Size = Vector3.new(4.361, 4.698, 2.481),
			Transparency = 0.99,
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.Glass,
		})		
	else
		AntiDeath:Initalize("Head", Script.Head, {
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightArm", Script.RightArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftArm", Script.LeftArm, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("RightLeg", Script.RightLeg, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("LeftLeg", Script.LeftLeg, {
			Size = Vector3.new(1,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Torso", Script.Torso, {
			Size = Vector3.new(2,2,1),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Horn", Script.Horn, {
			Size = Vector3.new(1.43, 1.438, 0.513),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Wing", Script.Wing, {
			Size = Vector3.new(4.361, 4.698, 2.481),
			Color = Color3.fromRGB(127, 127, 127),
			Material = Enum.Material.SmoothPlastic,
		})
	end

	if charname == "Jolly Dummy" then
		AntiDeath:Initalize("Gun", Script.Gun, {
			Size = Vector3.new(6.792, 1.241, 0.254),
			Color = Color3.fromRGB(0, 0, 0),
			TextureID = "rbxassetid://5605201",
			Material = Enum.Material.SmoothPlastic,
		})
	else
		AntiDeath:Initalize("Gun", Script.Gun, {
			Size = Vector3.new(6.792, 1.241, 0.254),
			Color = Color3.fromRGB(0, 0, 0),
			Material = Enum.Material.SmoothPlastic,
		})
		AntiDeath:Initalize("Crown", Script.Crown, {
			Size = Vector3.new(1.673, 1.269, 1.673),
			Color = Color3.fromRGB(0, 0, 0),
			Material = Enum.Material.SmoothPlastic,
		})
	end

end
local function UpdateMode(Mode_)
	if Mode == Mode_ then
		return
	end
	Mode = Mode_
	local Parts = {}
	for i,v in pairs(Character) do
		table.insert(Parts, v)
	end
	ChangeChar(Mode_)
	for i,v in pairs(Parts) do
		Destroy(v)
	end
end
local Overlaps = OverlapParams.new()
local Sound = nil

local Billboards = {}
function Chat(Text)
	if Text:sub(1,5) == "!play" or Text:sub(1,5) == "!Play" or Text:sub(1,5) == "!pitch" or Text:sub(1,5) == "!Pitch" or Text:sub(1,5) == "/e" then return end
	if not Player:FindFirstChildOfClass("PlayerGui") then
		return
	end
	coroutine.resume(coroutine.create(function()
		local function gargar22(ID, PARENT, VOLUME, PITCH, DOESLOOP)
			local NEWSOUND = Instance.new("Sound")
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND.Looped = DOESLOOP
			NEWSOUND:play()
			return NEWSOUND
		end
		local function Textsound(id, vol, pitch, timepos)
			if not id then return end
			local s = Instance.new("Sound")
			s.Name = RandomString()
			s.Volume = vol or 3
			s.PlaybackSpeed = pitch or 1
			s.SoundId = id
			s.TimePosition = timepos or 0
			s.PlayOnRemove = true
			s.Playing = true
			s.Parent = game:GetService("RunService")
			pcall(game.Destroy,s)
			return s
		end
		local function otherrandomstring(length)
			local array = {}
			for i = 1,length do
				array[i] = string.char(math.random(14,255))
			end
			return table.concat(array)
		end
		local NotifHolder = Instance.new("ScreenGui")
		NotifHolder.DisplayOrder = 2147483647
		NotifHolder.Name = RandomString()
		NotifHolder.ResetOnSpawn = false
		NotifHolder.Archivable = true
		local NotifText = Instance.new("TextLabel")
		NotifText.BackgroundTransparency = 1
		NotifText.Name = RandomString()
		NotifText.Position = UDim2.new(0,0,1,0)
		NotifText.Text = "[Hyper Redone Studio Dummy]:"
		NotifText.Size = UDim2.new(1,0,.05,0)
		NotifText.Archivable = true
		NotifText.TextSize = 14
		NotifText.Font = Enum.Font.SpecialElite
		NotifText.TextScaled = true
		NotifText.TextColor3 = Color3.new(1, 1, 1)
		NotifText.TextStrokeTransparency = 0
		NotifText.TextXAlignment = Enum.TextXAlignment.Left
		NotifText.Parent = NotifHolder
		NotifHolder.Parent = Player:FindFirstChildOfClass("PlayerGui")
		NotifText:TweenPosition(UDim2.new(0,0,.95,0))
		local Timer = tick()
		task.wait(1.25)
		Timer = tick()
		local LastLen = 0
		repeat
			task.wait(0.016666666666666666)
			local Len = math.floor((tick()-Timer)*30)
			if Len > LastLen then
				LastLen = Len
				task.spawn(Textsound,"rbxassetid://385470791",10,1,0)
			end
			NotifText.Text = "[Hyper Redone Studio Dummy]:"..string.sub(Text,0,Len)
		until tick()-Timer >= string.len(Text)/30
		NotifText.Text = "[Hyper Redone Studio Dummy]:"..Text
		Timer = tick()
		task.wait(3.8)
		gargar22(169112309,NotifHolder,2,math.random(5, 15) / 10,false)
		for i = 1,50 do
			task.wait()
			NotifText.Position = NotifText.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3))
			NotifText.Rotation = NotifText.Rotation + math.random(-5,5)
			NotifText.Text = otherrandomstring(250)
			NotifText.Font = Enum.Font:GetEnumItems()[math.random(1,#Enum.Font:GetEnumItems())]
			NotifText.TextStrokeTransparency = i/50
			NotifText.TextTransparency = NotifText.TextStrokeTransparency
		end
		game:GetService("TweenService"):Create(NotifText,TweenInfo.new(1,Enum.EasingStyle.Linear),{TextTransparency = 1,TextStrokeTransparency = 1}):Play()
		game:GetService("Debris"):AddItem(NotifText,1)
		game:GetService("Debris"):AddItem(NotifHolder,3)
	end))
end
local SoundIds = {
	["Female"] = "97931485922608|.9",
	["Hrsd"] = "84045957909284|.9",
	["Anger"] = "16190783774|.75",
	["WimP"] = "15689458182|1",
	["Classic"] = "1837463416|1",
	["Jolly Dummy"] = "1839286325|.9"
}

local mousehit = CFrame.identity
local cameracf = CFrame.identity

local rfloordistance = 0
local lfloordistance = 0

local lastcframes = {}

pcall(function()
	lastcframes = {
		table.clone(RootJoint),
		table.clone(RightHip),
		table.clone(Neck),
		table.clone(LeftHip),
		table.clone(RightShoulder),
		table.clone(LeftShoulder),
	}
end)
local LastPos = CFrame.new()
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local animsig = game:GetService("RunService").RenderStepped:Connect(function()
	for i,v in pairs(Billboards) do
		if v and v:IsDescendantOf(workspace) then
			v.Adornee = Character.Head
			v.StudsOffsetWorldSpace = Vector3.new(0,2,0) + Vector3.new(0,0.01+(#Billboards-i)*2.5,0)
		end
	end
	local Info = SoundIds[Mode]
	if SharedClient.SkiddedEffects then
		Info = SharedClient.HrsdTheme
	end
	local Splited = string.split("84045957909284|.9","|")
	if Info then
		Splited = string.split(Info,"|")
	end
	local SoundParent = Character.Head
	if SharedClient.SkiddedEffects then
		SoundParent = game:GetService("SoundService")
	end
	if not Sound or Sound.Parent ~= SoundParent or not pcall(function() return Sound.Name end) then
		pcall(game.Destroy,Sound)
		Sound = Instance.new("Sound")
		Sound.PlaybackSpeed = Splited[2] or .9
		Sound.Volume = (Values.Muted and 0 or 4)
		Sound.SoundId = "rbxassetid://"..Splited[1]
		Sound.Looped = true
		Sound.Name = tick()
		Sound.TimePosition = Values.TimePosition or 0
		Sound.Playing = true
		Sound.Parent = SoundParent
	end

	Sound.PlaybackSpeed = Splited[2] or 1
	Sound.Volume = (Values.Muted and 0 or 4)
	Sound.SoundId = "rbxassetid://"..Splited[1]
	Sound.Looped = true
	Sound.Name = tick()
	Values.TimePosition = (os.clock()*Sound.PlaybackSpeed)%Sound.TimeLength
	if(math.abs((Sound.TimePosition - Values.TimePosition)) > .25) and not SharedClient.SkiddedEffects then
		Sound.TimePosition = Values.TimePosition
	end
	Sound.Playing = true
	Sound.Parent = SoundParent

	rad1 = rad1 + .1
	if rad1>=360 then
		rad1 = 0
	end
	local Sine = tick()*60
	ssine=ssine+(1/2)
	if not attacking then
		if not SharedClient.SkiddedEffects then
			gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(Sine/30)/5,0.95400238)*euler(rad(0),rad(60),rad(-182.5-cos(Sine/30)*10)),animspeed)
			CFrameAnimation = false
			if Movement.Flight then
				if Movement.State == "Idle" then
					local Sine = tick()*60
					RootJoint.C0 = Lerp(RootJoint.C0, CFrame.new(0, 0.285*math.cos(Sine/30), -0.085*math.cos(Sine/30)+0.025*math.sin(Sine/30), -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(5-4*math.sin(Sine/30)),0,0), 0.3)
					LeftShoulder.C0 = Lerp(LeftShoulder.C0, CFrame.new(-1-0.01*math.sin(Sine/30), 0.4+0.05*math.cos(Sine/30), 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(math.rad(-2+1*math.sin(Sine/30)),math.rad(5+4.5*math.sin(Sine/30)),math.rad(5*math.cos(Sine/30)+3*math.sin(Sine/30))), 0.3)
					Neck.C0 = Lerp(Neck.C0, CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(5-6*math.sin(Sine/30)+2.5*math.cos(Sine/30)),0,0), 0.3)
					RightShoulder.C0 = Lerp(RightShoulder.C0, CFrame.new(1-0.01*math.sin(Sine/30), 0.4+0.05*math.cos(Sine/30), 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(math.rad(-2+1*math.sin(Sine/30)),math.rad(-5-4.5*math.sin(Sine/30)),math.rad(-5*math.cos(Sine/30)-3*math.sin(Sine/30))), 0.3)
					RightHip.C0 = Lerp(RightHip.C0, CFrame.new(1, -1-0.14*math.cos(Sine/30), -0.25-0.05*math.cos(Sine/30), 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(math.rad(1),math.rad(-5-2.5*math.sin(Sine/30)),math.rad(-9-5*math.cos(Sine/30))), 0.3)
					LeftHip.C0 = Lerp(LeftHip.C0, CFrame.new(-1, -0.75-0.1*math.cos(Sine/30), -0.45+0.1*math.cos(Sine/30), 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(math.rad(-1),math.rad(5-3.5*math.sin(Sine/30)),math.rad(15-5*math.cos(Sine/30))), 0.3)
				elseif Movement.State == "Walking" then
					local Sine = tick()*70
					RightShoulder.C0 = Lerp(RightShoulder.C0, CFrame.new(1+0.02*math.sin(Sine/30), 0.45, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(math.rad(-5-5*math.sin(Sine/30)),math.rad(-15-1*math.sin(Sine/30)),math.rad(-25-5*math.sin(Sine/30))), animspeed)
					LeftHip.C0 = Lerp(LeftHip.C0, CFrame.new(-1, -0.5, -0.65, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(math.rad(1),0,math.rad(25-5*math.sin(Sine/30)+3.5*math.cos(Sine/30))), animspeed)
					LeftShoulder.C0 = Lerp(LeftShoulder.C0, CFrame.new(-1-0.02*math.sin(Sine/30), 0.4, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(math.rad(-5-5*math.sin(Sine/30)),math.rad(15+1*math.sin(Sine/30)),math.rad(25+5*math.sin(Sine/30))), animspeed)
					RightHip.C0 = Lerp(RightHip.C0, CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(math.rad(1),0,math.rad(-5+0.2*math.sin(Sine/30))), animspeed)
					Neck.C0 = Lerp(Neck.C0, CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(-25-5*math.sin(Sine/30)),0,0), animspeed)
					RootJoint.C0 = Lerp(RootJoint.C0, CFrame.new(0, 0.5*math.cos(Sine/30), 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(63-4*math.sin(Sine/30)),0,0), animspeed)
				end
			else
				if Movement.State == "Jumping" then
					Neck.C0 = Lerp(Neck.C0, CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(20),0,0), animspeed)
					LeftHip.C0 = Lerp(LeftHip.C0, CFrame.new(-1, -1, -0.1, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(0,math.rad(5),math.rad(15)), animspeed)
					RightHip.C0 = Lerp(RightHip.C0, CFrame.new(1, -0.4,- 1, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(0,math.rad(-5),math.rad(-33)), animspeed)
					RightShoulder.C0 = Lerp(RightShoulder.C0, CFrame.new(1.25, 0.25, animspeed, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(math.rad(-70),0,math.rad(40)), animspeed)
					LeftShoulder.C0 = Lerp(LeftShoulder.C0, CFrame.new(-1.25, 0.25, animspeed, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(math.rad(-70),0,math.rad(-40)), animspeed)
					RootJoint.C0 = Lerp(RootJoint.C0, CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(-10),0,0), animspeed)
				elseif Movement.State == "Falling" then
					Neck.C0 = Lerp(Neck.C0, CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(20),0,0), animspeed)
					LeftHip.C0 = Lerp(LeftHip.C0, CFrame.new(-1, -1, -0.1, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(0,0,math.rad(5)), animspeed)
					RightHip.C0 = Lerp(RightHip.C0, CFrame.new(1, -0.4,- 1, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(0,0,math.rad(-25)), animspeed)
					RightShoulder.C0 = Lerp(RightShoulder.C0, CFrame.new(1.75, 0.25, 0.1, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(math.rad(240),0,math.rad(-10)), animspeed)
					LeftShoulder.C0 = Lerp(LeftShoulder.C0, CFrame.new(-1.75, 0.25, 0.1, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(math.rad(240),0,math.rad(10)), animspeed)
					RootJoint.C0 = Lerp(RootJoint.C0, CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(10),0,0), animspeed)
				elseif Movement.State == "Walking" then
					local TestDir = Vector3.new(0,0,1)
					local Direction = Movement and Clamp(Movement.CFrame:VectorToObjectSpace(Movement.LerpedVelocity), -1, 1) or TestDir
					local Sine = tick()*60
					local Speed = 11
					local Direction = Direction or Vector3.new(1,0,0)
					RightShoulder.C0 = Lerp(RightShoulder.C0,  CFrame.new(1+(0.05*math.sin(Sine/Speed))*Direction.X, 0.45+0.0051*math.sin(Sine/Speed)-0.1*math.sin(Sine/Speed), -0.25*math.sin(Sine/Speed)*Direction.Z, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(math.rad(-1*math.cos(Sine/Speed))+math.rad(-7*math.sin(Sine/Speed))*Direction.X,math.rad(-1+0.5*math.cos(Sine/Speed))+math.rad(-Direction.X*-2*math.sin(Sine/Speed)*Direction.X),math.rad(5+22*math.sin(Sine/Speed)-7*math.cos(Sine/Speed))*Direction.Z)*CFrame.new(0.05*math.sin(Sine/30),0.041*math.cos(Sine/30),0), animspeed)
					LeftShoulder.C0 = Lerp(LeftShoulder.C0,  CFrame.new(-1+(0.05*math.sin(Sine/Speed))*Direction.X, 0.45-0.0051*math.sin(Sine/Speed)+0.1*math.sin(Sine/Speed), 0.25*math.sin(Sine/Speed)*Direction.Z, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(math.rad(-1*math.cos(Sine/Speed))+math.rad(7*math.sin(Sine/Speed))*Direction.X,math.rad(1-0.5*math.cos(Sine/Speed))+math.rad(-Direction.X*-2*math.sin(Sine/Speed)*Direction.X),math.rad(-5+22*math.sin(Sine/Speed)-7*math.cos(Sine/Speed))*Direction.Z)*CFrame.new(-0.06*math.sin(Sine/30),0.041*math.cos(Sine/30),0), animspeed)
					RightHip.C0 = Lerp(RightHip.C0,  CFrame.new(1-(0.15*-Direction.X*math.cos(Sine/Speed)*Direction.X), -1-0.25*math.cos(Sine/Speed), (-0.14+0.1*math.cos(Sine/Speed)+0.2*math.sin(Sine/Speed))*Direction.Z, 0, 0, 1, 0, 1, -0, -1, 0, 0)*CFrame.Angles(math.rad(-25*math.sin(Sine/Speed))*Direction.X,math.rad(12*Direction.X),math.rad(-5-55*math.sin(Sine/Speed)+9.5*math.cos(Sine/Speed))*Direction.Z)*CFrame.new(0,-0.02*math.sin(Sine/30),0), animspeed)
					LeftHip.C0 = Lerp(LeftHip.C0,  CFrame.new(-1+(0.15*-Direction.X*math.cos(Sine/Speed)*Direction.X), -1+0.25*math.cos(Sine/Speed), (-0.14+-0.1*math.cos(Sine/Speed)-0.2*math.sin(Sine/Speed))*Direction.Z, 0, 0, -1, 0, 1, 0, 1, 0, 0)*CFrame.Angles(math.rad(-25*math.sin(Sine/Speed))*Direction.X,math.rad(12*Direction.X),math.rad(5-55*math.sin(Sine/Speed)+9.5*math.cos(Sine/Speed))*Direction.Z)*CFrame.new(0,-0.02*math.sin(Sine/30),0), animspeed)
					Neck.C0 = Lerp(Neck.C0,  CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(1.2*math.cos(Sine/Speed))*Direction.Z,math.rad(0.1*math.cos(Sine/Speed)),math.rad(0.1*math.sin(Sine/Speed))+math.rad(35)*Direction.X), animspeed)
					RootJoint.C0 = Lerp(RootJoint.C0,  CFrame.new(0, -0.05*math.sin(Sine/Speed), 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)*CFrame.Angles(math.rad(12.5+1.5*math.sin(Sine/(Speed))+2*math.cos(Sine/Speed))*Direction.Z,math.rad(5-2*math.cos(Sine/Speed))*Direction.X,math.rad(10+5*math.sin(Sine/(Speed*0.95)))*Direction.X)*CFrame.Angles(0,0,math.rad(2*math.cos(Sine/Speed*0.85))*Direction.Z)*CFrame.new(0,0,0.009*math.sin(Sine/Speed)), animspeed)
				elseif Movement.State == "Idle" then
					local sine = Sine
					RootJoint.C0 = Lerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + .05 * math.cos(sine / 16)) * CFrame.Angles(math.rad(4 + 2 * math.cos(sine / 16)),math.rad(0),math.rad(-8)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Lerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(9 + 3 * math.sin(sine / 16)),math.rad(0),math.rad(0)),1 / 3)
					RightShoulder.C0 = Lerp(RightShoulder.C0,CFrame.new(1.5,.5 + .025 * math.cos(sine / 16),0) * CFrame.Angles(math.rad(8.12 + 1.5 * math.cos(sine / 16)),math.rad(-17 + 2.5 * math.sin(sine / 16)),math.rad(6.7)) * rscp,1 / 3)
					LeftShoulder.C0 = Lerp(LeftShoulder.C0,CFrame.new(-1.5,.5 + .03 * math.cos(sine / 16),-0) * CFrame.Angles(math.rad(0),math.rad(3.5 + 2 * math.sin(sine / 16)),math.rad(-4 + 1.5 * math.cos(sine / 16))) * lscp,1 / 3)
					RightHip.C0 = Lerp(RightHip.C0,CFrame.new(1,-1 - .05 * math.cos(sine / 16),-.2 + .05 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-2.5 + 4 * math.cos(sine / 16)),math.rad(-12),math.rad(3)) * CFrame.Angles(math.rad(-0),math.rad(90),math.rad(0)),1 / 3)
					LeftHip.C0 = Lerp(LeftHip.C0,CFrame.new(-1,-1 - .05 * math.cos(sine / 16),-.2 + .05 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-2.5 + 4 * math.cos(sine / 16)),math.rad(15),math.rad(-5)) * CFrame.Angles(math.rad(-0),math.rad(-90),math.rad(0)),1 / 3)
				end
			end
		else
			local fly,moving = Movement.Flight,Movement.State == "Walking"
			local _tilt = cn(Movement.CFrame:VectorToObjectSpace(Movement.LerpedVelocity))
			local tilt = {X= -clamp(_tilt.X,-7,7),Y=0,Z= -clamp(_tilt.Z,-7,7)}
			local sine = workspace.DistributedGameTime*60
			local gay = SharedClient.Modes or "Null"
			local function cn2(x,y,z)
				return cn(x*1,y*1,z*1)
			end
			CFrameAnimation = true
			if Movement.State == "Jumping" and not fly then
				laoffset = laoffset:Lerp(lac0*cn(-0.325000763,0.187000036,0)*euler(0,0,rad(-30)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.325000763,0.187000036,0)*euler(0,0,rad(30)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(0,0.57099998,-0.45300293)*euler(rad(-7.5),0,0),animspeed)
				rloffset = rloffset:Lerp(rlc0,animspeed)
				toffset = toffset:Lerp(cn(),animspeed)
				hoffset = hoffset:Lerp(hc0,animspeed)
			elseif Movement.State == "Falling" and not fly then
				laoffset = laoffset:Lerp(lac0*cn(-0.187999725,0.161999941,-0.46900177)*euler(rad(60),0,rad(-30)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.187999725,0.161999941,-0.46900177)*euler(rad(60),0,rad(30)),animspeed)
				lloffset = lloffset:Lerp(llc0,animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0,0.57099998,-0.45300293)*euler(rad(-7.5),0,0),animspeed)
				toffset = toffset:Lerp(euler(rad(-20),0,0),animspeed)
				hoffset = hoffset:Lerp(hc0*cn(0,-0.0170001984,-0.128997803)*euler(rad(-7.5),0,0),animspeed)
			elseif moving and (gay == "NormalHrsd" or gay == "Duper" or gay == "Hall of WHAT") then
				laoffset = laoffset:Lerp(lac0*cn(-0.0429992676,0.0380001068-cos(sine/20)/7,-0.700996399)*euler(rad(60),rad(15),rad(-7.5+cos(sine/20)*5)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051-cos(sine/20)/7,-0.800003052)*euler(rad(75),rad(67.5),0),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(sin(sine/10)/20*tilt.X,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(sin(sine/10)*3*tilt.X)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(-sin(sine/10)/20*tilt.X,0,-sin(sine/10)/20*tilt.Z)*euler(rad(sin(sine/10)*3*tilt.Z),0,-rad(sin(sine/10)*3*tilt.X)),animspeed)
				toffset = toffset:Lerp(cn(0,sin(sine/5)/10,0)*euler(rad(tilt.Z*2),0,rad(-tilt.X)),animspeed)
				hoffset = hoffset:Lerp(hc0*euler(0,-rad(tilt.X*5),0),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
			elseif moving and gay == "kickisher" then
				toffset = toffset:Lerp(CF(0, 1.8+.2*math.sin(sine/6), 0) * ANGLES(RAD(-50), RAD(0), RAD(0)), 0.2/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(-30+2*cos(sine/0.000000000001)), RAD(10+2*cos(sine/0.000000000001)), RAD(-3*cos(sine/0.000000000001))), 0.4/3)
				raoffset = raoffset:Lerp(CF(1.6, -0.1+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(0+5*cos(sine/13)), RAD(-80), RAD(10)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.4/3)
				laoffset = laoffset:Lerp(CF(-0.5, 0.6, -0.5) * ANGLES(RAD(180+4*cos(sine/13)), RAD(90), RAD(-40)) * ANGLES(RAD(-30), RAD(0), RAD(0)), 1/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.02,0.3-0.2*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.02,0-0.2*cos(sine/18)/7,0) *ANGLES(RAD(0+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/2)
				gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
			elseif moving and gay == "CRAZYYYYY WACKER" then
				laoffset = laoffset:Lerp(lac0*cn(-0.1,0,-sin(sine/10)/20*tilt.Z)*euler(rad(sin(sine/10)*3*tilt.Z),0,rad(-10)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.1,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(10)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(sin(sine/10)/20*tilt.X,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(sin(sine/10)*3*tilt.X)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(-sin(sine/10)/20*tilt.X,0,-sin(sine/10)/20*tilt.Z)*euler(rad(sin(sine/10)*3*tilt.Z),0,-rad(sin(sine/10)*3*tilt.X)),animspeed)
				toffset = toffset:Lerp(cn(0,sin(sine/5)/10,0)*euler(rad(tilt.Z*2),0,rad(-tilt.X)),animspeed)
				hoffset = hoffset:Lerp(hc0*euler(0,-rad(tilt.X*5),0),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.125,-0.898999929-cos(sine/10)/70*tilt.Z,0.95400238)*euler(0,rad(90),rad(-172.5+cos(sine/10)*tilt.Z*1.5)),animspeed)
			elseif moving and (gay == "SUPER MAD" or gay == "AHHOY" or gay == "kickisher") then
				toffset = toffset:Lerp(CF(0, 1.8+.2*math.sin(sine/6), 0) * ANGLES(RAD(-50), RAD(0), RAD(0)), 0.2/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(-30+2*cos(sine/0.000000000001)), RAD(10+2*cos(sine/0.000000000001)), RAD(-3*cos(sine/0.000000000001))), 0.4/3)
				raoffset = raoffset:Lerp(CF(1.6, -0.1+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(0+5*cos(sine/13)), RAD(-80), RAD(10)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.4/3)
				laoffset = laoffset:Lerp(CF(-0.5, 0.6, -0.5) * ANGLES(RAD(180+4*cos(sine/13)), RAD(90), RAD(-40)) * ANGLES(RAD(-30), RAD(0), RAD(0)), 1/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.02,0.3-0.2*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.02,0-0.2*cos(sine/18)/7,0) *ANGLES(RAD(0+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/2)
				gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
			elseif moving and gay == "wario" then
				toffset = toffset:Lerp(CF(0, 3+.5*math.sin(sine/15), 0) * ANGLES(RAD(-50 + 3 * math.cos(sine/15)+tilt.Z*2), RAD(0), RAD(-2 * cos(sine/30)-tilt.X)), 0.4/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0,-0) * ANGLES(RAD(30), RAD(0), RAD(-5*cos(sine/30))), 0.4/3)
				raoffset = raoffset:Lerp(CF(1.95, 0.3, 0.7) * ANGLES(RAD(50+-15*cos(sine/15)), RAD(-120), RAD(-30)) * ANGLES(RAD(120+4*cos(sine/30)), RAD(0), RAD(0)), 0.4/3)
				laoffset = laoffset:Lerp(CF(-1.2, -0, 0.2) * ANGLES(RAD(-0), RAD(90), RAD(-40)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.4-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-45+3*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 1/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.08-0.03*cos(sine/20)/7,-0.2) *ANGLES(RAD(-6+4*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
				gunoffset = gunoffset:Lerp(CF(-0.4,-2,0) * ANGLES(RAD(180),RAD(0),RAD(90)),0.1)
			elseif moving and (gay == "limits who" or gay == "The Chaos") then
				toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(-50+-5*math.cos(sine/15)), RAD(0), RAD(0)), 0.4/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(40+4*cos(sine/15)), RAD(0), RAD(-10*cos(sine/30))), 0.7/3)
				raoffset = raoffset:Lerp(CF(1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(30+2*cos(sine/15)), RAD(-90), RAD(40)) * ANGLES(RAD(40+4*cos(sine/17)), RAD(0), RAD(0)), 0.7/3)
				laoffset = laoffset:Lerp(CF(-1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(30+2*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(40+4*cos(sine/18)), RAD(0), RAD(0)), 0.4/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.4-0.01*cos(sine/20)/7,-0.6) * ANGLES(RAD(-50+2*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 0.4/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.04,0.6-0.01*cos(sine/20)/7,0.4) *ANGLES(RAD(-40+1*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.4/2)
				gunoffset = gunoffset:Lerp(CF(0.2,0.3,0.7) * ANGLES(RAD(0),RAD(0),RAD(45)),0.1)
			elseif moving and gay == "boss" then
				laoffset = laoffset:Lerp(lac0*cn2(1.00899887,0.371999979,-0.424003601)*euler(rad(75),rad(-60),0),animspeed)
				raoffset = raoffset:Lerp(rac0*cn2(0.241001129,0.16899991,0.255996704)*euler(0,rad(-15),rad(75)),animspeed)
				lloffset = lloffset:Lerp(llc0,animspeed)
				rloffset = rloffset:Lerp(rlc0*cn2(0,0.541000009,-0.31199646)*euler(rad(-30),0,0),animspeed)
				toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(-50),0,0),animspeed)
				hoffset = hoffset:Lerp(cn2(0,1,0)*euler(rad(50),0,0)*cn2(0,0.5,0),animspeed)
			elseif moving and (gay == "depressed SKID XD"  or "the horizon") then
				toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(-70+-3*math.cos(sine/17)+tilt.Z*2), RAD(0), RAD(0-tilt.X)), 0.3/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0,-0.1) * ANGLES(RAD(-30+4*cos(sine/0.000000000001)), RAD(0+4*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.3/3)
				raoffset = raoffset:Lerp(CF(1.7, 0.2+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-20+5*cos(sine/15)), RAD(-80), RAD(40)) * ANGLES(RAD(20+4*cos(sine/17)), RAD(0), RAD(0)), 0.3/3)
				laoffset = laoffset:Lerp(CF(-0.2, 1.3+0.07*math.sin(sine/16), -0.5) * ANGLES(RAD(160+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-90+4*cos(sine/18)), RAD(0), RAD(0)), 1/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.3) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(8), RAD(0), RAD(0)), 1/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.1-0.01*cos(sine/20)/7,-0.2) *ANGLES(RAD(20+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
				gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
			elseif (gay == "NormalHrsd" or gay == "Duper" or gay == "Hall of WHAT") then	
				laoffset = laoffset:Lerp(lac0*cn(-0.0429992676,0.0380001068-cos(sine/20)/7,-0.700996399)*euler(rad(60),rad(15),rad(-7.5+cos(sine/20)*5)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051-cos(sine/20)/7,-0.800003052)*euler(rad(75),rad(67.5),0),animspeed)
				lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed)
				rloffset = rloffset:Lerp(rlc0,animspeed)
				toffset = toffset:Lerp(euler(rad(cos(sine/30)*2.5-2),rad(-15),0),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(cos(sine/30)*5),rad(15),rad(cos(sine/60)*10))*cn(0,0.5,0),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
			elseif gay == "boss" then
				toffset = toffset:Lerp(CF(0, 3+.5*math.sin(sine/15), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 * sin(sine/30))), 0.7/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0,-0) * ANGLES(RAD(0), RAD(0), RAD(-5*math.cos(sine/30))), 0.7/3)
				raoffset = raoffset:Lerp(CF(1.7, 0.5, -0) * ANGLES(RAD(135+-15*math.cos(sine/30)), RAD(-90), RAD(-20)) * ANGLES(RAD(25+5*math.cos(sine/30)), RAD(0), RAD(0)), 0.7/3)
				laoffset = laoffset:Lerp(CF(-1.6, 0, -0) * ANGLES(RAD(-0), RAD(90), RAD(20)) * ANGLES(RAD(10+5*math.sin(sine/30)), RAD(0), RAD(0)), 1/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.08,-0.2) * ANGLES(RAD(10+3*math.sin(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 1/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.08,-0.2) *ANGLES(RAD(10-3*math.sin(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
				gunoffset = gunoffset:Lerp(CF(-0.4,-1.7,0) * ANGLES(RAD(180),RAD(0),RAD(100)),0.1)
			elseif gay == "SUPER MAD" or gay == "AHHOY" or gay == "kickisher" then
				toffset = toffset:Lerp(CF(0, 1+.2*math.sin(sine/15), 0) * ANGLES(RAD(0), RAD(20), RAD(0)), 0.4/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(-30+2*cos(sine/0.000000000001)), RAD(-15+2*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.4/3)
				raoffset = raoffset:Lerp(CF(1.6, -0.1+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-20+5*cos(sine/15)), RAD(-80), RAD(10)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.4/3)
				laoffset = laoffset:Lerp(CF(-0.4, 0.6, -0.5) * ANGLES(RAD(180+3*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-30), RAD(0), RAD(0)), 1/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.02,0.5-0.2*cos(sine/20)/7,-0.5) * ANGLES(RAD(-10+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.02,0.1-0.2*cos(sine/20)/7,-0.6) *ANGLES(RAD(50+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/2)
				gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
			elseif gay == "CRAZYYYYY WACKER" then
				laoffset = laoffset:Lerp(lac0*cn(0.262001038-sin(sine/30)/10,-0.0739998817,-0.13999939)*euler(rad(7.44),0,rad(7.56-sin(sine/30)*7)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(-0.125,-0.125,0.217002869-sin(sine/30)/10)*euler(rad(-7.5+sin(sine/30)*7),rad(-30),0),animspeed)
				lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0,0.0160000324,0.124000549)*euler(rad(-7.5),0,0),animspeed)
				toffset = toffset:Lerp(euler(rad(cos(sine/30)*2.5-2),rad(-15),0),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(cos(sine/30)*5),rad(15),rad(cos(sine/60)*10))*cn(0,0.5,0),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(60),rad(-172.5-cos(sine/30)*10)),animspeed)
			elseif gay == "wario" then
				toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * EULER(RAD(40), RAD(30), RAD(-30+5*cos(sine/30))), 0.4/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.2) * EULER(RAD(-30), RAD(-35), RAD(-5*cos(sine/30))), 0.7/3)
				raoffset = raoffset:Lerp(CF(1.5, 0.5, -0.3) * EULER(RAD(30), RAD(-90), RAD(-30)) * EULER(RAD(10+4*cos(sine/30)), RAD(0), RAD(0)), 0.7/3)
				laoffset = laoffset:Lerp(CF(-1.5, -0, 0) * EULER(RAD(90), RAD(90), RAD(-40)) * EULER(RAD(35), RAD(0), RAD(0)), 1/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.2,0.5-0.01*cos(sine/20)/7,-0.8) * EULER(RAD(-40+3*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(22), RAD(0), RAD(0)), 1/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.04,0.08-0.01*cos(sine/20)/7,-0) *EULER(RAD(-16-2*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
				gunoffset = gunoffset:Lerp(CF(-0.4,-1.7,0) * EULER(RAD(180),RAD(0),RAD(100)),0.1)
			elseif gay == "limits who" or gay == "The Chaos" then
				toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(20+-3*math.cos(sine/17)), RAD(-40), RAD(30)), 0.4/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.1) * ANGLES(RAD(-30+4*cos(sine/15)), RAD(35), RAD(-10*cos(sine/30))), 0.4/3)
				raoffset = raoffset:Lerp(CF(1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(10+5*cos(sine/15)), RAD(-90), RAD(40)) * ANGLES(RAD(20+4*cos(sine/17)), RAD(0), RAD(0)), 0.4/3)
				laoffset = laoffset:Lerp(CF(-1.2, 0.7+0.07*math.sin(sine/16), -0.5) * ANGLES(RAD(30+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-150+4*cos(sine/18)), RAD(0), RAD(0)), 0.4/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.4/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(0,0,0.8) *ANGLES(RAD(-40+4*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.4/2)
				gunoffset = gunoffset:Lerp(CF(0.2,0.3,0.7) * ANGLES(RAD(0),RAD(0),RAD(45)),0.1)
			elseif gay == "depressed SKID XD" or gay == "the horizon" then
				toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(20+-3*math.cos(sine/17)), RAD(20), RAD(20)), 0.4/3)
				hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.1) * ANGLES(RAD(-30+4*cos(sine/0.000000000001)), RAD(20+4*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.4/3)
				raoffset = raoffset:Lerp(CF(1.7, 0.2+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-50+5*cos(sine/15)), RAD(-80), RAD(40)) * ANGLES(RAD(50+4*cos(sine/17)), RAD(0), RAD(0)), 0.4/3)
				laoffset = laoffset:Lerp(CF(-0.2, 1.3+0.07*math.sin(sine/16), -0.7) * ANGLES(RAD(180+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-95+4*cos(sine/18)), RAD(0), RAD(0)), 1/3)
				rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(8), RAD(0), RAD(0)), 1/3)
				lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.4,0.1-0.01*cos(sine/20)/7,-0.7) *ANGLES(RAD(50+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(-23), RAD(0), RAD(0)), 1/2)
				gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
			end
		end
	end

	pcall(function()
		local relativeCFrame = Inverse(RootJoint)
		local worldPosition = relativeCFrame.Position

		local rrpos = worldPosition + relativeCFrame:VectorToWorldSpace(Vector3.new(0.5, -1.5, 0))
		local llpos = worldPosition + relativeCFrame:VectorToWorldSpace(Vector3.new(-0.5, -1.5, 0))

		local param = RaycastParams.new()
		param.FilterDescendantsInstances = {Character["RightLeg"], Character["LeftLeg"]}

		local rray = workspace:Raycast(rrpos, Vector3.yAxis*-1.5, param)
		local lray = workspace:Raycast(llpos, Vector3.yAxis*-1.5, param)

		local rpos, lpos = rray and rray.Position or nil, lray and lray.Position or nil

		if(rpos)then
			rfloordistance = lerpnum(rfloordistance, (rpos.Y-rrpos.Y)+1.5, .1)
		else
			rfloordistance = lerpnum(rfloordistance, 0, .1)
		end
		if(lpos)then
			lfloordistance = lerpnum(lfloordistance, (lpos.Y-llpos.Y)+1.5, .1)
		else
			lfloordistance = lerpnum(lfloordistance, 0, .1)
		end
	end)
	if not CFrameAnimation then
		pcall(function()
			CFrames.Torso = Inverse(lastcframes[1])
			CFrames.RightLeg = Inverse(lastcframes[2], CFrames.Torso)
			CFrames.Head = Inverse(lastcframes[3], CFrames.Torso)
			CFrames.LeftLeg = Inverse(lastcframes[4], CFrames.Torso)
			CFrames.RightArm = Inverse(lastcframes[5], CFrames.Torso)
			CFrames.LeftArm = Inverse(lastcframes[6], CFrames.Torso)
		end)
	else
		CFrames.Torso = Movement.CFrame*toffset
		CFrames.RightLeg = CFrames.Torso*rloffset
		CFrames.Head = CFrames.Torso*hoffset
		CFrames.LeftLeg = CFrames.Torso*lloffset
		CFrames.RightArm = CFrames.Torso*raoffset
		CFrames.LeftArm = CFrames.Torso*laoffset
	end
	pcall(function()
		CFrames.Gun = CFrames.RightArm*gunoffset

		CFrames.Horn = CFrames.Head*CFrame.new(0,1,0)
		CFrames.Wing = CFrames.Torso*CFrame.new(0,-0.6,1)
		local sinenum = (os.clock() * 60)/40
		CFrames.Crown = CFrames.Head*CFrame.new(0,3,0)*CFrame.Angles(sinenum,sinenum,sinenum)


		CFrames.JollyHat = CFrames.Head*CFrame.new(-0.14, 1.15, 0)
		CFrames.Goob = CFrames.Torso*CFrame.new(-0.02,0.248,-0.676)*CFrame.fromEulerAnglesYXZ(math.rad(-27.267),math.rad(-26.17),math.rad(28.248))
		CFrames.Glasses = CFrames.Head*CFrame.new(0.01,-0.09,-0.3)*CFrame.fromEulerAnglesYXZ(math.rad(0),math.rad(-90),math.rad(0))
		CFrames.FemaleHair = CFrames.Head*CFrame.new(0,-0.7,0.1)
		CFrames.Scarf = CFrames.Torso*CFrame.new(0,1.1,0)
		CFrames.Scarf1 = CFrames.Torso*CFrame.new(0,0.9,0)
		CFrames.TailOfc = CFrames.Torso*CFrame.new(0.05,-1.525,1.45)
	end)

	pcall(function()
		lastcframes = {
			table.clone(RootJoint),
			table.clone(RightHip),
			table.clone(Neck),
			table.clone(LeftHip),
			table.clone(RightShoulder),
			table.clone(LeftShoulder),
		}
	end)

	if(math.random(1, 50) == 1) and Mode == "Anger" then
		for i, v in next, Character do
			pcall(function()
				if(v and v:IsA("BasePart"))then
					local arch = v.Archivable
					v.Archivable = true
					local EffectPart = v:Clone()
					EffectPart:ClearAllChildren()
					v.Archivable = arch
					EffectPart.Parent = workspace
					EffectPart.CanCollide = false
					EffectPart.CanQuery = false
					EffectPart.Anchored = true
					EffectPart.Material = "Neon"
					EffectPart.Transparency = .5

					customtween(EffectPart, TweenInfo.new(0.75), {
						Transparency = 1,
						Color = Color3.new()
					}, animfps):Play()

					customtween(EffectPart, TweenInfo.new(2.75,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut), {
						Size = Vector3.new(0,0,0),
						Orientation = Vector3.new(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)),
						Position = EffectPart.Position+Vector3.new(math.random(-8, 8), math.random(-8, 8), math.random(-8, 8))
					}, animfps):Play()

					task.delay(.75, pcall, game.Destroy, EffectPart)
				end
			end)
		end
	end



	pcall(function()
		Character.Humanoid.DisplayName = Player.Name
		Character.Humanoid.NameOcclusion = Enum.NameOcclusion.NoOcclusion
	end)

	for i,v in pairs(CFrames) do
		pcall(function()
			if Character[i] ~= nil and Character[i]:IsA("BasePart") then
				Character[i].CFrame = v
			end
		end)
	end
end)

game:GetService("RunService").RenderStepped:Connect(function()
	if Character["Gun"] and Mode ~= "Jolly Dummy" then

		if not wow or wow.Parent ~= Character["Gun"] then
			wow = Instance.new("Highlight",Character["Gun"])
			table.insert(Ignores,wow)
			wow.Enabled = true
			wow.FillColor = Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255))
			wow.FillTransparency = math.random(-5,1)
			wow.OutlineColor = hicolor
			wow.OutlineTransparency = 0
		else
			wow.Enabled = true
			wow.FillColor = Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255))
			wow.FillTransparency = math.random(-5,1)
			wow.OutlineColor = hicolor
			wow.OutlineTransparency = 0
		end
	end
	if Character["Crown"] then
		if not HG or HG.Parent ~= Character["Crown"] then
			HG = Instance.new("Highlight",Character["Crown"])
			HG.Enabled = true
			HG.FillColor = hicolor
			HG.FillTransparency = 0
			HG.OutlineColor = Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255))
		else
			HG.Enabled = true
			HG.FillColor = hicolor
			HG.FillTransparency = 0
			HG.OutlineColor = Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255))
		end
	end
end)
local SkiddedModes = {
	{Name = "NormalHrsd",Value = "7028919492|.9"},
	{Name = "depressed SKID XD", Value = function()
		local Audio = "9038254566|1"
		if math.random(1,5) == 1 then
			Audio = "133411773241503|.1"
		end
		return Audio
	end},
	{Name = "limits who",Value = "1847595103|1"},
	{Name = "kickisher",Value = "7023887630|1"},
	{Name = "wario",Value = "5410082346|1"},
	{Name = "CRAZYYYYY WACKER",Value = "5410085296|1"},
	{Name = "SUPER MAD",Value = "5410080475|.9"},
	{Name = "The Chaos",Value = "7028977687|.9"},
	{Name = "the horizon",Value = "5410084426|.9"},
	{Name = "boss",Value = "1840040963|1"},
	{Name = "Duper",Value = "5410086149|.9"},
	{Name = "Hall of WHAT",Value = "1839900676|1"},
	{Name = "AHHOY", Value = function()
		local Audio = "1843675857|.9"
		if math.random(1,3) == 1 then
			Audio = "1843675710|.9"
		end
		return Audio
	end}
}
local SampleTable = {Size = {},ClassNamess = {},Connection = {},MeshIDs = {}}
local function VoidObj(obj)
	if obj:IsA("BasePart") then
		if Values.AttackVer then
			Remote:FireServer(RemoteKey,"Kill",obj)
		else
			local POSITION = CFrame.new(0,1e9,0)
			local HIT = obj
			local function Verify(obj)
				if not table.find(Ignores,obj) then
					if obj:IsA("MeshPart") or obj:IsA("SpecialMesh") and table.find(SampleTable.MeshIDs,obj.MeshId) then
						return true
					end
					if obj:IsA("BasePart") and table.find(SampleTable.Size,obj.Size) and table.find(SampleTable.ClassNamess,obj.ClassName) then
						return true
					end
				end
				return false
			end
			if HIT and not table.find(Ignores,HIT) then
				table.insert(SampleTable.Size,HIT.Size)
				table.insert(SampleTable.ClassNamess,HIT.ClassName)
				if HIT:IsA("MeshPart") then
					table.insert(SampleTable.MeshIDs,HIT.MeshId)
				elseif HIT:FindFirstChildWhichIsA("SpecialMesh") then
					table.insert(SampleTable.MeshIDs,HIT:FindFirstChildWhichIsA("SpecialMesh").MeshId)
				end
				HIT.CFrame = POSITION
				table.insert(SampleTable.Connection,HIT.Changed:Connect(function()
					if HIT.CFrame ~= POSITION then
						HIT.CFrame = POSITION
					else
						HIT.Size = Vector3.new(0.1,0.1,0.1)
						HIT.CFrame = POSITION
					end
				end))
				table.insert(SampleTable.Connection,game.DescendantAdded:Connect(function(obcs)
					if Verify(obcs) then
						if obcs:IsA("SpecialMesh") then
							table.insert(SampleTable.Connection,obcs.Parent.Changed:Connect(function()
								if obcs.Parent.CFrame ~= POSITION then
									obcs.Parent.CFrame = POSITION
								else
									obcs.Parent.Size = Vector3.new(0.1,0.1,0.1)
									obcs.Parent.CFrame = POSITION
								end
							end))
							obcs.Parent.CFrame = POSITION
						else
							table.insert(SampleTable.Connection,obcs.Changed:Connect(function()
								if obcs.CFrame ~= POSITION then
									obcs.CFrame = POSITION
								else
									obcs.Size = Vector3.new(0.1,0.1,0.1)
									obcs.CFrame = POSITION
								end
							end))
							obcs.CFrame = POSITION
						end
					end
				end))
				table.insert(SampleTable.Connection,workspace.DescendantAdded:Connect(function(obcs)
					if Verify(obcs) then
						if obcs:IsA("SpecialMesh") then
							table.insert(SampleTable.Connection,obcs.Parent.Changed:Connect(function()
								if obcs.Parent.CFrame ~= POSITION then
									obcs.Parent.CFrame = POSITION
								else
									obcs.Parent.Size = Vector3.new(0.1,0.1,0.1)
									obcs.Parent.CFrame = POSITION
								end
							end))
							obcs.Parent.CFrame = POSITION
						else
							table.insert(SampleTable.Connection,obcs.Changed:Connect(function()
								if obcs.CFrame ~= POSITION then
									obcs.CFrame = POSITION
								else
									obcs.Size = Vector3.new(0.1,0.1,0.1)
									obcs.CFrame = POSITION
								end
							end))
							obcs.CFrame = POSITION
						end
					end
				end))
			end
		end
	end
end

local function GetObjs(pos,rad)
	task.spawn(function()
		for i,obj in pairs(workspace:GetDescendants()) do
			if obj:IsA("BasePart") and obj ~= workspace:FindFirstChildWhichIsA("Terrain") and not table.find(Ignores,obj) then
				local mag = (obj.Position - pos).Magnitude
				if mag <= (rad or 10) then
					VoidObj(obj)
				end
			end
		end
	end)
end
local thrown = 0
local Info = TweenInfo.new(0.04,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut)
local function swait(num)
	if num == 0 or num == nil then
		game:GetService("RunService").RenderStepped:Wait()
	else
		for i = 1, num do
			game:GetService("RunService").RenderStepped:Wait()
		end
	end
end
local Attacks = {}
Attacks.B = function()
	Chat("Cleared Tables")
	Remote:FireServer(RemoteKey, "CleanTables")
	for i,v in pairs(SampleTable.Connection) do
		if v then
			v:Disconnect()
		end
	end
	SampleTable = {Size = {},ClassNamess = {},Connection = {},MeshIDs = {}}
end
local visModel

Attacks.E = function()
	attacking = true
	CFrameAnimation = true
	for i = 1, 3, 0.2 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(15),0),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(0.301998138,0.25999999,-0.476997375)*euler(rad(75),0,rad(45)),animspeed)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed)
		rloffset = rloffset:Lerp(rlc0,animspeed)
		toffset = toffset:Lerp(euler(0,rad(-30),0),animspeed)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(30),0),animspeed)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-2.6,-0.424999237)*euler(rad(0.06),rad(0.98),rad(75.06)),animspeed)
	end
	local Hitbox = Instance.new("Part")
	table.insert(Ignores,Hitbox)
	Hitbox.Shape = Enum.PartType.Ball
	Hitbox.Name = RandomString()
	Hitbox.CastShadow = false
	Hitbox.Anchored = true
	Hitbox.CanCollide = false
	Hitbox.Material = Enum.Material.ForceField
	Hitbox.Color = Color3.new()
	Hitbox.Size = Vector3.new(9,9,9)
	Hitbox.CFrame = Movement.CFrame*cn(0,0,-7)
	Hitbox.Parent = workspace
	GetObjs((Movement.CFrame*cn(0,0,-7)).Position,4)
	for i = 1, 2, 0.15 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(15),0),animspeed*2)
		raoffset = raoffset:Lerp(rac0*cn(-0.459999084,0.112999916,-1.02799988)*euler(rad(75),0,rad(-30)),animspeed*2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed*2)
		rloffset = rloffset:Lerp(rlc0,animspeed*2)
		toffset = toffset:Lerp(euler(0,rad(30),0),animspeed*2)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(-30),0),animspeed*2)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-2.6,-0.424999237)*euler(rad(0.06),rad(0.98),rad(75.06)),animspeed)
	end
	game:GetService("TweenService"):Create(Hitbox,TweenInfo.new(1,Enum.EasingStyle.Linear),{LocalTransparencyModifier = 1}):Play()
	game:GetService("Debris"):AddItem(Hitbox,1)
	wait(.2)
	gunoffset = CFrame.new(-0.125,-0.898999929,0.95400238)*CFrame.fromEulerAnglesXYZ(0,math.rad(90),math.rad(-172.5))
	CFrameAnimation = false
	attacking = false
end
Attacks.click = function(actual)
	local pos = actual.p
	coroutine.resume(coroutine.create(function()
		attacking = true
		CFrameAnimation = true
		local function change(instance,properties)
			for i, v in next, properties do
				instance[i] = v
			end
		end
		local function create(class,properties)
			local instance = Instance.new(class)
			instance.Name = RandomString()
			change(instance,properties)
			return instance
		end
		local function septween(instance,properties,duration,easingdirection,easingstyle)
			pcall(function()
				if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
				game:GetService("TweenService"):Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
			end)	
		end
		local function createlightningbolt(startpos,endpos,width)
			local _start,length = startpos,(startpos-endpos).Magnitude
			local segments = clamp(math.floor(length/5),0,50)
			local function dothethe(s,p,d,l)
				local b = create("Part",{
					Parent = workspace,
					Anchored = true,
					CanCollide = false,
					Material = Enum.Material.Neon,
					Size = v3(width,width,l),
					Position = s,
					CFrame = cn(s,p) * euler(rad(random(-d,d)),rad(random(-d,d)),rad(random(-d,d)))
				})
				table.insert(Ignores,b)
				b.CFrame = b.CFrame * cn(0,0,-l/2)
				septween(b,{Size=v3(0,0,l),Transparency=1},0.2,Enum.EasingDirection.In,Enum.EasingStyle.Back)
				local flicker = game:GetService("RunService").RenderStepped:Connect(function()
					b.Color = Character["Gun"].Color
				end)
				delay(0.2,function()
					flicker:Disconnect()
				end)
				game:GetService("Debris"):AddItem(b,0.2)
				return (b.CFrame * cn(0,0,-l/2)).p
			end
			for i = 1, segments do
				_start = dothethe(_start,endpos,20,5)
			end
			dothethe(_start,endpos,0,(_start-endpos).Magnitude)
		end

		for i = 1, 3, 0.1 do
			swait()
			laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(15),0),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.0480003357,0.375,-0.614997864)*euler(rad(90),rad(-22.5),0),animspeed)
			lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed)
			rloffset = rloffset:Lerp(rlc0,animspeed)
			toffset = toffset:Lerp(euler(0,rad(22.5),0),animspeed)
			hoffset = hoffset:Lerp(hc0*euler(0,rad(-22.5),0),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
		end
		local start = (Movement.CFrame*raoffset*gunoffset * cn(3.43700027,0.504000008,0.00199890137)).p
		local bruurubu = create("Part",{
			Parent = workspace,
			Anchored = true,
			CanCollide = false,
			Material = Enum.Material.Neon,
			Size = v3(1.5,1.5,1.5),
			CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		septween(bruurubu,{Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360)),Size=v3()},0.2,Enum.EasingDirection.In)
		game:GetService("Debris"):AddItem(bruurubu,0.2)
		GetObjs(pos,10)
		for i = 1, 2 do
			createlightningbolt(start,pos,0.5)
			createlightningbolt(start,pos,0.2)
			local function dosomethingidk()
				local  raycastparams = RaycastParams.new()
				raycastparams.FilterDescendantsInstances = Ignores
				raycastparams.FilterType,raycastparams.IgnoreWater = Enum.RaycastFilterType.Exclude,true
				local sp = 800
				local raycast = workspace:Raycast(start,(cn(start,pos)*euler(rad(random(-sp,sp)/sp),rad(random(-sp,sp)/sp),rad(random(-sp,sp)/sp))).LookVector*2048,raycastparams)
				if raycast then
					return raycast.Position
				else
					return (cn(start)*cn(start,pos)*cn(0,0,-2048)).p
				end
			end
			local hitpos = dosomethingidk()
			local length = clamp((start-hitpos).Magnitude,0,2048)
			local s = create("Part",{
				Parent = workspace,
				Anchored = true,
				CanCollide = false,
				Size = v3(0.5,0.5,length),
				Material = Enum.Material.Neon,
				Position = start,
				CFrame = cn(start,hitpos)
			})
			table.insert(Ignores,s)
			s.CFrame = s.CFrame * cn(0,0,-length/2)

			septween(s,{Size=v3(0,0,length),Transparency=1},0.2,Enum.EasingDirection.In)
			game:GetService("Debris"):AddItem(s,0.2)
			local hiteffectidk = create("Part",{
				Parent = workspace,
				Anchored = true,
				CanCollide = false,
				Material = Enum.Material.Neon,
				Size = v3(1.5,1.5,1.5),
				CFrame = cn(hitpos) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
			})
			table.insert(Ignores,hiteffectidk)
			septween(hiteffectidk,{Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360)),Size=v3()},0.2,Enum.EasingDirection.In)
			game:GetService("Debris"):AddItem(hiteffectidk,0.2)
			local shock = Instance.new("Part")
			change(shock,{
				Parent = workspace,
				Anchored = true,
				CanCollide = false,
				Size = v3(0.1,0.1,0.1),
				Material = Enum.Material.Neon,
				CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
			})
			table.insert(Ignores,shock)
			septween(shock,{Size=v3(0.1,random(5,7),0.1),Transparency=1},random(5,15)/30,Enum.EasingDirection.Out)
			game:GetService("Debris"):AddItem(shock,0.5)
		end
		for i = 1, 3, 0.15 do
			swait()
			laoffset = laoffset:Lerp(lac0*cn(-0.0429992676,0.0380001068,-0.700996399)*euler(rad(60),rad(15),rad(-7.5)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),animspeed)
			lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed)
			rloffset = rloffset:Lerp(rlc0,animspeed)
			toffset = toffset:Lerp(euler(0,rad(22.5),0),animspeed)
			hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
		end
		for i = 1, 2,0.3 do
			swait()
			laoffset = laoffset:Lerp(lac0*cn(0.199001312,0.0780000687,-0.694999695)*euler(rad(60),rad(15),rad(30)),animspeed*2)
			raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),animspeed*2)
			lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed*2)
			rloffset = rloffset:Lerp(rlc0,animspeed*2)
			toffset = toffset:Lerp(euler(0,rad(22.5),0),animspeed*2)
			hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),animspeed*2)
			gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed*2)
		end
		for i = 1, 2,0.3 do
			swait()
			laoffset = laoffset:Lerp(lac0*cn(-0.0429992676,0.0380001068,-0.700996399)*euler(rad(60),rad(15),rad(-7.5)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),animspeed)
			lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed)
			rloffset = rloffset:Lerp(rlc0,animspeed)
			toffset = toffset:Lerp(euler(0,rad(22.5),0),animspeed)
			hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
		end
		wait(.5)
		gunoffset = CFrame.new(-0.125,-0.898999929,0.95400238)*CFrame.fromEulerAnglesXYZ(0,math.rad(90),math.rad(-172.5))
		CFrameAnimation = false
		attacking = false
	end))
end

local cam = workspace:FindFirstChildWhichIsA("Camera")
local SkiddedStuff = {}
local sis = 0
local speen = 0
local hi,Blur,bloom
local skiddefeffects = game:GetService("RunService").RenderStepped:Connect(function()
	if not SharedClient.SkiddedEffects then
		local Lighting = game:GetService("Lighting")
		Lighting.Ambient = Color3.fromRGB(70, 70, 70)
		Lighting.Brightness = 3
		Lighting.ColorShift_Top = Color3.new(0, 0, 0)
		Lighting.ColorShift_Bottom = Color3.new(0, 0, 0)
		Lighting.EnvironmentDiffuseScale = 1
		Lighting.EnvironmentSpecularScale = 1
		Lighting.GlobalShadows = true
		Lighting.OutdoorAmbient = Color3.fromRGB(70, 70, 70)
		Lighting.ShadowSoftness = .2
		Lighting.ClockTime = 12
		Lighting.GeographicLatitude = 0
		Lighting.FogColor = Color3.fromRGB(255, 255, 255)
		Lighting.FogStart = math.huge
		Lighting.FogEnd = math.huge
		Lighting.ExposureCompensation = 0
		hicolor = Color3.new(1,1,1)
		if #SkiddedStuff > 0 then
			for i,Obj in pairs(SkiddedStuff) do
				table.remove(SkiddedStuff,table.find(SkiddedStuff,Obj))
				pcall(game.Destroy,Obj)
				pcall(game.Remove,Obj)
			end
		end
		return
	end
	cam.CoordinateFrame = cam.CoordinateFrame * CFrame.Angles(math.rad(.3 * math.sin(tick()-math.random()/tick() * .1)), math.rad(0.5 * math.sin(tick()-math.random()/tick() * 0.1)),math.rad(15 * math.sin(tick()-math.random()/tick() * 1)))
	if not hi or hi.Parent ~= game:GetService("Lighting") then
		hi = Instance.new("ColorCorrectionEffect",game:GetService("Lighting"))
		table.insert(SkiddedStuff,hi)
		hi.Name = RandomString()
		hi.Enabled = true
		hi.TintColor = hicolor
		hi.Archivable = true
	else
		hi.Enabled = true
		hi.TintColor = hicolor
	end
	if not bloom or bloom.Parent ~= game:GetService("Lighting") then
		bloom = Instance.new("BloomEffect",game:GetService("Lighting"))
		table.insert(SkiddedStuff,Blur)
		bloom.Name = RandomString()
		bloom.Archivable = true
	end
	if not Blur or Blur.Parent ~= game:GetService("Lighting") then
		Blur = Instance.new("BlurEffect",game:GetService("Lighting"))
		table.insert(SkiddedStuff,Blur)
		Blur.Size = 0
		Blur.Name = RandomString()
	end
	local gay = SharedClient.Modes
	local r,t = {CFrame = Movement.CFrame},{CFrame = CFrames.Torso}
	local sine = workspace.DistributedGameTime*60
	local bgm,sick = Sound,Sound
	local function tween(instance,properties,duration,easingdirection,easingstyle)
		pcall(function()
			if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
			game:GetService("TweenService"):Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
		end)	
	end
	local function CameraShake(Length,Intensity)
		coroutine.resume(coroutine.create(function()
			local intensity = 1 + Intensity
			local rotM = 0.01 * Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05 * Intensity / Length
				rotM = rotM - 5.0E-4 * Intensity / Length
				cam.CoordinateFrame = cam.CoordinateFrame * CF(RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity))) * EULER(RAD(MRANDOM(-intensity, intensity)) * rotM, RAD(MRANDOM(-intensity, intensity)) * rotM, RAD(MRANDOM(-intensity, intensity)) * rotM)
			end
		end))
	end
	speen = speen + 0.1
	if speen == 360 then
		speen = 0
	end
	sis = sis + 0.2 
	if sis >= 21 then
		sis = 0
	end
	game:GetService("Lighting").ClockTime = sis
	game:GetService("Lighting").GeographicLatitude = speen

	if gay == "NormalHrsd" then
		for i,v in next, LocalPlayer:FindFirstChild("PlayerGui"):GetDescendants() do
			pcall(function()
				if v:IsA("Frame") or v:IsA("TextLabel") or v:IsA("TextBox") or v:IsA("TextButton") or v:IsA("ScrollingFrame") or v:IsA("ImageLabel") or v:IsA("ImageButton") then
					v.Rotation = 0
				end
			end)
		end
		local sn = tick()*60
		hicolor = Color3.new(1,1,1)
		hi.Saturation = 0
		game:GetService("Lighting").OutdoorAmbient = Color3.fromRGB(70, 70, 70)
		WACKYEFFECT({Time = 15, EffectType = "Block", Size = Vector3.new(0.1,2,0.1), Size2 = Vector3.new(0,2,0), Transparency = 0, Transparency2 = 0, CFrame = Movement.LastCFrame*CFrame.new(0-9*math.sin(sine/55),0-2*math.sin(sine/75),0-9*math.cos(sine/55))*CFrame.Angles(math.rad(-sine*1),math.rad(-sine*2),math.rad(-sine*3)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromHSV(tick() % 5 / 5,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 15, EffectType = "Block", Size = Vector3.new(2,0.1,0.1), Size2 = Vector3.new(2,0,0), Transparency = 0, Transparency2 = 0, CFrame = Movement.LastCFrame*CFrame.new(0-9*math.sin(sine/55),0-2*math.sin(sine/75),0-9*math.cos(sine/55))*CFrame.Angles(math.rad(-sine*1),math.rad(-sine*2),math.rad(-sine*3)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromHSV(tick() % 5 / 5,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif gay == "the horizon" then
		local baseHue = (tick() % 5) / 5
		local PSRGB = Color3.fromHSV(baseHue, 1,math.clamp(bgm.PlaybackLoudness / 100, 0, 1))
		local PushBack = bgm.PlaybackLoudness/25
		hi.Saturation = 0
		hicolor = Color3.new(1,1,1)
		game:GetService("Lighting").ClockTime = PushBack
		game:GetService("Lighting").GeographicLatitude = 110+PushBack
		game:GetService("Lighting").OutdoorAmbient = Color3.fromRGB(70, 70, 70)
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(7+bgm.PlaybackLoudness/55,0.55,7+bgm.PlaybackLoudness/55), Size2 = VT(7+bgm.PlaybackLoudness/25,0.55,7+bgm.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(bgm.PlaybackLoudness),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = PSRGB, SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(10+bgm.PlaybackLoudness/25,0.44,10+bgm.PlaybackLoudness/25), Size2 = VT(10+bgm.PlaybackLoudness/55,0.44,10+bgm.PlaybackLoudness/55), Transparency = 0.6, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(-bgm.PlaybackLoudness/2),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
	elseif gay == "AHHOY" then
		for i,v in next, LocalPlayer:FindFirstChild("PlayerGui"):GetDescendants() do
			pcall(function()
				if v:IsA("Frame") or v:IsA("TextLabel") or v:IsA("TextBox") or v:IsA("TextButton") or v:IsA("ScrollingFrame") or v:IsA("ImageLabel") or v:IsA("ImageButton") then
					v.Rotation = 0
				end
			end)
		end
		local PushBack = bgm.PlaybackLoudness/15
		game:GetService("Lighting").ClockTime = sis
		game:GetService("Lighting").GeographicLatitude = 110+PushBack
		hi.Saturation = 0
		hicolor = Color3.new(1,1,1)
		Blur.Size = 0
		bloom.Intensity = 0
		game:GetService("Lighting").FogEnd = math.huge
		game:GetService("Lighting").FogColor = hicolor
		game:GetService("Lighting").FogStart = math.huge
		game:GetService("Lighting").Ambient = Color3.fromRGB(244, 244, 244)
		game:GetService("Lighting").FogColor = Color3.new(0.752941, 0.752941, 0.752941)
		game:GetService("Lighting").FogEnd = 100000
		game:GetService("Lighting").FogStart = 0
		game:GetService("Lighting").OutdoorAmbient = Color3.new(0.27451, 0.27451, 0.27451)
	elseif gay == "Hall of WHAT" then	
		hicolor = Color3.new(1,1,1)
		local PushBack = bgm.PlaybackLoudness/5
		game:GetService("Lighting").ClockTime = sis*2
		game:GetService("Lighting").GeographicLatitude = 110+PushBack
		CameraShake(1,1+bgm.PlaybackLoudness/6)
		WACKYEFFECT({Time = .95, EffectType = "Sphere", Size = VT(7+bgm.PlaybackLoudness/25,0.05,7+bgm.PlaybackLoudness/25), Size2 = VT(7+bgm.PlaybackLoudness/25,0.05,7+bgm.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color =  Color3.new(1, 1, 1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif gay == "Duper" then
		local hue = tick() % 5 / 5
		hicolor = Color3.fromHSV(hue,1,1)
		Blur.Size = 0
		bloom.Intensity = 0
		game:GetService("Lighting").FogEnd = math.huge
		game:GetService("Lighting").FogColor = hicolor
		game:GetService("Lighting").FogStart = math.huge
		game:GetService("Lighting").Ambient = Color3.fromRGB(244, 244, 244)
		game:GetService("Lighting").FogColor = Color3.new(0.752941, 0.752941, 0.752941)
		game:GetService("Lighting").FogEnd = 100000
		game:GetService("Lighting").FogStart = 0
		game:GetService("Lighting").OutdoorAmbient = Color3.new(0.27451, 0.27451, 0.27451)
		WACKYEFFECT({Time = 25,
			EffectType = "Sphere",
			Size = VT(0,0,0),
			Size2 = VT(7+bgm.PlaybackLoudness/25,0.55,7+bgm.PlaybackLoudness/25),
			Transparency = 0.3,
			Transparency2 = 1,
			CFrame = r.CFrame*CF(0,-3,0),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0, 
			RotationZ = 0,
			Material = "Neon",
			Color = Color3.fromHSV(hue,1,1),
			SoundID = nil,
			SoundPitch = 1,
			SoundVolume = 0})
		WACKYEFFECT({TIME = 15, EffectType = "Block", Size = Vector3.new(0.1,2,0.1), Size2 = Vector3.new(0,2,0), Transparency = 0, Transparency2 = 0, CFrame = r.CFrame*CFrame.new(0-9*math.sin(sine/55),0-2*math.sin(sine/75),0-9*math.cos(sine/55))*CFrame.Angles(math.rad(-sine*1),math.rad(-sine*2),math.rad(-sine*3)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromHSV(hue,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 15, EffectType = "Block", Size = Vector3.new(2,0.1,0.1), Size2 = Vector3.new(2,0,0), Transparency = 0, Transparency2 = 0, CFrame = r.CFrame*CFrame.new(0-9*math.sin(sine/55),0-2*math.sin(sine/75),0-9*math.cos(sine/55))*CFrame.Angles(math.rad(-sine*1),math.rad(-sine*2),math.rad(-sine*3)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromHSV(hue,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		workspace.CurrentCamera.FieldOfView = bgm.PlaybackLoudness/40 + 80
	elseif gay == "The Chaos" then
		for i,v in next, LocalPlayer:FindFirstChild("PlayerGui"):GetDescendants() do
			pcall(function()
				if v:IsA("Frame") or v:IsA("TextLabel") or v:IsA("TextBox") or v:IsA("TextButton") or v:IsA("ScrollingFrame") or v:IsA("ImageLabel") or v:IsA("ImageButton") then
					v.Rotation = math.random(-bgm.PlaybackLoudness/10*math.random(1,3),bgm.PlaybackLoudness/10*math.random(1,2))
				end
			end)
		end
		hicolor = Color3.new(0+bgm.PlaybackLoudness/800,0,0)
		hi.Saturation = math.floor(1+bgm.PlaybackLoudness/2)
		CameraShake(1,1+bgm.PlaybackLoudness/50)
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(7+bgm.PlaybackLoudness/55,0.55,7+bgm.PlaybackLoudness/55), Size2 = VT(7+bgm.PlaybackLoudness/25,0.55,7+bgm.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(bgm.PlaybackLoudness),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*bgm.PlaybackLoudness/100,0+178*bgm.PlaybackLoudness/100,0+178*bgm.PlaybackLoudness/100), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(10+bgm.PlaybackLoudness/25,0.44,10+bgm.PlaybackLoudness/25), Size2 = VT(10+bgm.PlaybackLoudness/55,0.44,10+bgm.PlaybackLoudness/55), Transparency = 0.6, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(-bgm.PlaybackLoudness/2),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})		
		WACKYEFFECT({Time = 47, EffectType = "Sphere", Size = VT(1.081, 0.267, 0.211), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.4, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(10*math.sin(sine/45),math.random(-10,10),10*math.cos(sine/45))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(0+178*bgm.PlaybackLoudness/100,0+178*bgm.PlaybackLoudness/100,0+178*bgm.PlaybackLoudness/100), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 47, EffectType = "Sphere", Size = VT(0.581, 0.067, 0.011), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.7, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(-10*math.sin(sine/45),math.random(-10,10),-10*math.cos(sine/45))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0.581, 0.067, 0.011), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.7, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(-5*math.sin(sine/5),math.random(-10,10),-5*math.cos(sine/5))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(0,175,255), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
	elseif gay == "SUPER MAD" then
		for i,v in next, LocalPlayer:FindFirstChild("PlayerGui"):GetDescendants() do
			pcall(function()
				if v:IsA("Frame") or v:IsA("TextLabel") or v:IsA("TextBox") or v:IsA("TextButton") or v:IsA("ScrollingFrame") or v:IsA("ImageLabel") or v:IsA("ImageButton") then
					v.Rotation = 0
				end
			end)
		end
		hicolor = Color3.new(1,1,1)
		hi.Saturation = 0
		CameraShake(1,1+bgm.PlaybackLoudness/15)	
	elseif gay == "CRAZYYYYY WACKER" then
		for i,v in next, LocalPlayer:FindFirstChild("PlayerGui"):GetDescendants() do
			pcall(function()
				if v:IsA("Frame") or v:IsA("TextLabel") or v:IsA("TextBox") or v:IsA("TextButton") or v:IsA("ScrollingFrame") or v:IsA("ImageLabel") or v:IsA("ImageButton") then
					v.Rotation = math.random(-bgm.PlaybackLoudness/10*math.random(1,3),bgm.PlaybackLoudness/10*math.random(1,2))
				end
			end)
		end
		CameraShake(1,1+bgm.PlaybackLoudness/50)
		hicolor = Color3.fromRGB(0+135*bgm.PlaybackLoudness/100,0,0+135*bgm.PlaybackLoudness/80)
	elseif gay == "kickisher" then
		hi.Saturation = 0
		local hue = tick() % 5 / 5
		hicolor = Color3.fromHSV(hue,1,1)
		tween(hi,{TintColor = hicolor},1,Enum.EasingDirection.Out,Enum.EasingStyle.Cubic)
		tween(game:GetService("Lighting"),{Ambient = hicolor},1,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{OutdoorAmbient = hicolor},1,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{EnvironmentSpecularScale = bgm.PlaybackLoudness/2},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{EnvironmentDiffuseScale = bgm.PlaybackLoudness/2},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*bgm.PlaybackLoudness/75,0,1*bgm.PlaybackLoudness/75), Size2 = VT(1*bgm.PlaybackLoudness/75,0.5,7*bgm.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(bgm.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = hi.TintColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*bgm.PlaybackLoudness/75,0,10*bgm.PlaybackLoudness/75), Size2 = VT(7*bgm.PlaybackLoudness/75,0.69,1*bgm.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(bgm.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = hi.TintColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*bgm.PlaybackLoudness/75,0,4*bgm.PlaybackLoudness/75), Size2 = VT(4*bgm.PlaybackLoudness/75,0.5,4*bgm.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(bgm.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = 	hi.TintColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif gay == "wario" then
		WACKYEFFECT({Time = 25,
			EffectType = "Sphere",
			Size = VT(0,0,0),
			Size2 = VT(7+bgm.PlaybackLoudness/25,0.55,7+bgm.PlaybackLoudness/25),
			Transparency = 0.3,
			Transparency2 = 1,
			CFrame = r.CFrame*CF(0,-3,0),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0, 
			RotationZ = 0,
			Material = "Neon",
			Color = Color3.fromRGB(0+55*bgm.PlaybackLoudness/100,0,0+55*bgm.PlaybackLoudness/80),
			SoundID = nil,
			SoundPitch = 1,
			SoundVolume = 0})
		CameraShake(1,1+bgm.PlaybackLoudness/50)
		WACKYEFFECT({Time = 5, EffectType = "Crystal", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.1, Transparency2 = 1, CFrame = t.CFrame*laoffset*CFrame.new(0,-1.6,0)*CFrame.fromEulerAnglesXYZ(RAD(999*math.cos(sine/50)),RAD(0),RAD(999*math.cos(sine/50))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+55*bgm.PlaybackLoudness/100,0,0+55*bgm.PlaybackLoudness/80), SoundID = nil, SoundPitch = 1, SoundVolume = 0})		
		WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CF(8*math.cos(sine/3),-3,8*math.sin(sine/3)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+55*bgm.PlaybackLoudness/100,0,0+55*bgm.PlaybackLoudness/80), SoundID = nil, SoundPitch = 1, SoundVolume = 0,oriC = CFrame.new(0,0,0),posC = CFrame.new(0,0.5,0)})		
		hicolor = Color3.fromRGB(0+135*bgm.PlaybackLoudness/100,0,0+135*bgm.PlaybackLoudness/80)
	elseif gay == "limits who" then
		game:GetService("Lighting").ClockTime = 0
		WACKYEFFECT({Time = 47, EffectType = "Sphere", Size = VT(1.081, 0.267, 0.211), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.4, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(10*math.sin(sine/45),math.random(-10,10),10*math.cos(sine/45))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(0+178*bgm.PlaybackLoudness/100,0+178*bgm.PlaybackLoudness/100,0+178*bgm.PlaybackLoudness/100), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 47, EffectType = "Sphere", Size = VT(0.581, 0.067, 0.011), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.7, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(-10*math.sin(sine/45),math.random(-10,10),-10*math.cos(sine/45))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0.581, 0.067, 0.011), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.7, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(-5*math.sin(sine/5),math.random(-10,10),-5*math.cos(sine/5))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(0,175,255), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		hicolor = Color3.new(0+bgm.PlaybackLoudness/800,0,0)
		CameraShake(1,1+bgm.PlaybackLoudness/50)
		hi.Saturation = math.floor(1+bgm.PlaybackLoudness/2)
	elseif gay == "boss"  then
		game:GetService("Lighting").ClockTime = 0
		for i,v in next, LocalPlayer:FindFirstChild("PlayerGui"):GetDescendants() do
			pcall(function()
				if v:IsA("Frame") or v:IsA("TextLabel") or v:IsA("TextBox") or v:IsA("TextButton") or v:IsA("ScrollingFrame") or v:IsA("ImageLabel") or v:IsA("ImageButton") then
					v.Rotation = 0
				end
			end)
		end
		Blur.Size = math.clamp((bgm.PlaybackLoudness)-100, 0, 2)*2
		if bgm.PlaybackLoudness >= 255 then
			game:GetService("Lighting").ClockTime = 0
		else
			game:GetService("Lighting").ClockTime = 6
		end
		bloom.Intensity = math.clamp((bgm.PlaybackLoudness)-100, 0, 2)*2
		game:GetService("Lighting").FogEnd = 50+math.clamp((bgm.PlaybackLoudness)-100, 0, 2)*10
		game:GetService("Lighting").FogColor = hicolor
		game:GetService("Lighting").FogStart = 10
		game:GetService("Lighting").Ambient = hicolor
		if hicolor == Color3.fromRGB(0, 0, 0) or hicolor == Color3.fromRGB(5, 5, 5) or hicolor == Color3.fromRGB(10, 10, 10) then
			hicolor = Color3.fromRGB(25, 25, 25)
		end

		workspace.CurrentCamera.FieldOfView = bgm.PlaybackLoudness/25 + 70
		hicolor = c3(clamp(bgm.PlaybackLoudness-100,0,255),clamp(bgm.PlaybackLoudness-100,0,255),clamp(bgm.PlaybackLoudness-100,0,255))
		WACKYEFFECT({Time = .95, EffectType = "Sphere", Size = VT(7+bgm.PlaybackLoudness/25,0.05,7+bgm.PlaybackLoudness/25), Size2 = VT(7+bgm.PlaybackLoudness/25,0.05,7+bgm.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 1, 1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = VT(1.5,1.5,1.5)*3.95, Size2 = VT(0.425,0.425,0.425), Transparency = 0, Transparency2 = 0, CFrame = r.CFrame*CF(MRANDOM(-10,10),-5,MRANDOM(-10,10)), MoveToPos = r.CFrame*CF(MRANDOM(-10,10),5,MRANDOM(-10,10)).p, RotationX = math.random(-5,5), RotationY = math.random(-5,5), RotationZ = math.random(-5,5), Material = "Neon", Color =  Color3.new(0.721569, 0.721569, 0.721569), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		if math.random(1,25) == 1 then
			hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(math.random(-360,360)),rad(math.random(-360,360)),rad(math.random(-360,360)))*cn(math.random(-.5,.5),math.random(-.5,.5),math.random(-.5,.5)),1)
		end
	elseif gay == "depressed SKID XD"	then
		for i,v in next, LocalPlayer:FindFirstChild("PlayerGui"):GetDescendants() do
			pcall(function()
				if v:IsA("Frame") or v:IsA("TextLabel") or v:IsA("TextBox") or v:IsA("TextButton") or v:IsA("ScrollingFrame") or v:IsA("ImageLabel") or v:IsA("ImageButton") then
					v.Rotation = 0
				end
			end)
		end
		hi.Saturation = 0
		CameraShake(1,1+bgm.PlaybackLoudness/50)
		hicolor = Color3.new(1,1,1)
		game:GetService("Lighting").OutdoorAmbient = Color3.fromRGB(70, 70, 70)
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(7+bgm.PlaybackLoudness/55,0.55,7+bgm.PlaybackLoudness/55), Size2 = VT(7+bgm.PlaybackLoudness/25,0.55,7+bgm.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(bgm.PlaybackLoudness),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*bgm.PlaybackLoudness/100,0+178*bgm.PlaybackLoudness/100,0+178*bgm.PlaybackLoudness/100), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(10+bgm.PlaybackLoudness/25,0.44,10+bgm.PlaybackLoudness/25), Size2 = VT(10+bgm.PlaybackLoudness/55,0.44,10+bgm.PlaybackLoudness/55), Transparency = 0.6, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(-bgm.PlaybackLoudness/2),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
	end

end)
function Connect(Remote)
	Remote.OnClientEvent:Connect(function(Key, Method, ...)
		if Key ~= RemoteKey and Key ~= StopKey then
			return
		end
		local Args = {...}
		if Method == "Attack" then
			local Args = Args[1]
			if Args and Attacks[Args.Name] then
				Attacks[Args.Name](unpack(Args.Arguments or {CFrame.new(), nil}))
			end
		elseif Method == StopKey then
			StopScript()
		elseif Method == "CurrentInfo" then
			local Main = Args[1]
			if Main and type(Main) == "table" then
				for Name,Property in pairs(Main) do
					if Name and Property then
						SharedClient[Name] = Property
					end
				end
			end
		elseif Method == "UpdateMode" then
			UpdateMode(Args[1])
		elseif Method == "Chatted" then
			Chat(Args[1])
		elseif Method == "sendback" then
			thrown = thrown + 1
			local Args = Args[1]
			mousehit = Args.Mousehit
			cameracf = Args.CameraCF
			if not Values.IsOwner then
				for i,v in pairs(Args.Movement) do
					Movement[i] = v
				end
				for i,v in pairs(Args.Values) do
					if i ~= "IsOwner" then
						Values[i] = v
					end
				end
			end
		end
	end)
end
function CheckEvent(v)
	if v:IsA("RemoteEvent") and v:GetAttribute(RemoteName) == RemoteAttribute then
		Remote = v
		Connect(Remote)
	end
end
for _, v in next,game:GetDescendants() do
	pcall(CheckEvent, v)
end
game.DescendantAdded:Connect(function(v)
	pcall(CheckEvent, v)
end)

local movementsig = nil
local SkidMode = 1
if Values.IsOwner then
	if(not hnusable)then
		sendchatmessage("hnsable is not active")
	end
	local function IsKeyDown(Key)
		return not Services.UserInputService:GetFocusedTextBox() and Services.UserInputService:IsKeyDown(Enum.KeyCode[Key])
	end
	local Sprinting = false
	local Mouse = LocalPlayer:GetMouse()
	local Params = RaycastParams.new()
	Values.LastFrame = tick()
	Movement.WalkingVelocity = 0
	Movement.FallingSpeed = 0
	Movement.FloorDistance = Vector3.new(0,-2.95,0)
	local botmode = false
	local CMode = "Hrsd"

	Mouse.Button1Down:Connect(function()
		Remote:FireServer(RemoteKey, "Attack",
			{
				Name = "click",
				Arguments = {Mouse.Hit, Mouse.Target}
			}
		)
	end)
	Services.UserInputService.InputBegan:Connect(function(Input, Keyboard)
		if Keyboard then
			return
		end
		if Input.KeyCode == Enum.KeyCode.One then
			Values.Muted = not Values.Muted
			Services.StarterGui:SetCore("SendNotification", {
				Title = "destroyer",
				Text = string.format("song %s", (Values.Muted and "muted" or "unmuted"))
			})
		elseif Input.KeyCode == Enum.KeyCode.Two then
			botmode = not botmode
			Services.StarterGui:SetCore("SendNotification", {
				Title = "destroyer",
				Text = string.format("botmode %s", (Values.Magic and "enabled" or "disabled"))
			})
		elseif Input.KeyCode == Enum.KeyCode.Three then

			Values.AttackVer = not Values.AttackVer
			Services.StarterGui:SetCore("SendNotification", {
				Title = "destroyer",
				Text = string.format("Attack Type: %s", (Values.AttackVer and "Serversided" or "Clientsided"))
			})
		elseif Input.KeyCode == Enum.KeyCode.Four then
			SharedClient.SkiddedEffects = not SharedClient.SkiddedEffects

			if SharedClient.SkiddedEffects then
				Chat("skidded effects enabled")
			else
				Chat("skidded effects disabled")
			end

			Remote:FireServer(RemoteKey, "ChangeCurrent",{"SkiddedEffects",SharedClient.SkiddedEffects})
		elseif Input.KeyCode == Enum.KeyCode.P then
			Remote:FireServer(RemoteKey, "StopScript")
		elseif Input.KeyCode == Enum.KeyCode.M then
			local Modes = {"Hrsd","Female","Anger","WimP","Classic"}
			if CurrentDate.Month == 12 and CurrentDate.Day > 25 then
				if not table.find(Modes,"Jolly Dummy") then
					table.insert(Modes,"Jolly Dummy")
				end
			end


			if table.find(Modes, Mode) then
				local Next = Modes[table.find(Modes, Mode) + 1]
				local Modei = ""
				if Next then
					Modei = Next
				else
					Modei = Modes[1]
				end
				CMode = Modei
			end
		elseif Input.KeyCode == Enum.KeyCode.N then
			if SkidMode > #SkiddedModes-1 then
				SkidMode = 1
			else
				SkidMode = SkidMode+1
			end
			local Section = SkiddedModes[SkidMode]

			local SomeEvent = Section.Value
			if type(SomeEvent) == "function" then
				SomeEvent = SomeEvent()
			end
			Remote:FireServer(RemoteKey, "ChangeCurrent",{"HrsdTheme",SomeEvent or "140009716850576|.9"})
			Remote:FireServer(RemoteKey, "ChangeCurrent",{"Modes",Section.Name})
		elseif Input.KeyCode == Enum.KeyCode.Z then
			Movement.CFrame = CFrame.new(mousehit.Position+Vector3.new(0,3,0))
		elseif Input.KeyCode == Enum.KeyCode.R then
			Movement.CFrame = CFrame.new(0,100,0)

			for i,obj in pairs(Character) do
				pcall(game.Destroy,obj)
				pcall(game.Remove,obj)
			end
		elseif Input.KeyCode == Enum.KeyCode.F then
			local CameraCFrame = workspace:FindFirstChildWhichIsA("Camera").CFrame
			Movement.Flight = not Movement.Flight
			Movement.CFrame = CFrame.new(Movement.CFrame.Position, Vector3.new(Movement.CFrame.X + CameraCFrame.LookVector.X, Movement.CFrame.Y, Movement.CFrame.Z + CameraCFrame.LookVector.Z))
		else
			Remote:FireServer(RemoteKey, "Attack",
				{
					Name = Input.KeyCode.Name,
					Arguments = {Mouse.Hit, Mouse.Target}
				}
			)
		end
	end)

	Remote:FireServer(RemoteKey, "UpdateMode", CMode)
	movementsig = game:GetService("RunService").RenderStepped:Connect(function()
		Remote:FireServer(RemoteKey, "UpdateMode", CMode)
		if not Movement.Enabled then return end
		for i,v in pairs(Character) do
			pcall(ChangeCollisions, v, true)
		end
		local CameraCFrame = workspace:FindFirstChildWhichIsA("Camera").CFrame
		Params.FilterDescendantsInstances = Ignores
		local FeetPos = Movement.CFrame * CFrame.new(0,-1,0)
		local NextCFrame = CFrame.new(Movement.CFrame.Position, (Movement.Flight and Movement.CFrame.Position + CameraCFrame.LookVector or Vector3.new(Movement.CFrame.X + CameraCFrame.LookVector.X, Movement.CFrame.Y, Movement.CFrame.Z + CameraCFrame.LookVector.Z)))
		if not botmode then
			if IsKeyDown("W") then
				NextCFrame = NextCFrame * CFrame.new(0,0,-1)
			end
			if IsKeyDown("S") then
				NextCFrame = NextCFrame * CFrame.new(0,0,1)
			end
			if IsKeyDown("A") then
				NextCFrame = NextCFrame * CFrame.new(-1,0,0)
			end
			if IsKeyDown("D") then
				NextCFrame = NextCFrame * CFrame.new(1,0,0)
			end
		else
			local S = tick() * 37.5
			local Pivot = CFrame.new(math.cos(S / 60) * 35, 0, -math.sin(S / 60) * 35)
			for i,v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") and v:FindFirstChildWhichIsA("Humanoid") and v:FindFirstChild("HumanoidRootPart") then
					local RootPart = v:FindFirstChild("HumanoidRootPart")
					Pivot = RootPart.CFrame
					if (Movement.CFrame.Position - Pivot.Position).Magnitude < 5 then
						v:Destroy()
					end
					break
				end
			end
			NextCFrame = Pivot
		end
		local IsShiftlocked = Services.UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter
		local Old = Movement.CFrame
		if Movement.CFrame.Position ~= NextCFrame.Position then
			Movement.LastCFrame = Movement.CFrame
			if IsShiftlocked then
				Movement.WalkingVelocity = NumberLerp(Movement.WalkingVelocity, Movement.WalkSpeed, 0.25)
				Movement.CFrame = Movement.CFrame:Lerp(CFrame.new(Movement.CFrame.Position, NextCFrame.Position), 1)
			else
				Movement.WalkingVelocity = NumberLerp(Movement.WalkingVelocity, Movement.WalkSpeed, 0.25)
				Movement.CFrame = Movement.CFrame:Lerp(CFrame.new(Movement.CFrame.Position, NextCFrame.Position), 0.135)
			end
			local Last = Movement.CFrame
			Movement.CFrame = CFrame.new(Movement.LastCFrame.Position, NextCFrame.Position) * CFrame.new(0,0,(tick() - Values.LastFrame)*-(Movement.WalkingVelocity))
			Movement.CFrame = Last * CFrame.new((Last:Inverse() * Movement.CFrame).Position)
			Movement.State = "Walking"
		else
			Movement.WalkingVelocity = 0
			Movement.State = "Idle"
		end
		if not Movement.LerpedVelocity then
			Movement.LerpedVelocity = Vector3.new(0,0,-1)
		end
		Movement.LerpedVelocity = Movement.LerpedVelocity:Lerp(CFrame.new(Movement.CFrame.Position - NextCFrame.Position).Position*3.85,0.85)
		if not Movement.Flight then
			local FloorDistance = Movement.FloorDistance.Y+Movement.FallingSpeed/2
			local Raycast = workspace:Raycast(FeetPos.Position, Vector3.new(0,FloorDistance,0), Params)
			if Raycast then
				Movement.CFrame = CFrame.new(0,(Raycast.Position.Y-Movement.CFrame.Y)+3,0)*Movement.CFrame
				Movement.FallingSpeed = 0
				if IsKeyDown("Space") then
					Movement.FallingSpeed = 1
				end
			else
				Movement.FallingSpeed = math.clamp(Movement.FallingSpeed - workspace.Gravity / 3925, -math.huge, math.huge)
			end
			if Movement.FallingSpeed > 0 then
				Movement.State = "Jumping"
			elseif Movement.FallingSpeed < 0 then
				Movement.State = "Falling"
			end
			Movement.CFrame = Movement.CFrame * CFrame.new(0,Movement.FallingSpeed,0)
			if Movement.CFrame.Y < -90 then
				Movement.CFrame = CFrame.new(Movement.CFrame.X, 130, Movement.CFrame.Z)
				Movement.FallingSpeed = 0
			end
		end
		if IsShiftlocked then
			if Movement.Flight then
				Movement.CFrame = CFrame.new(Movement.CFrame.Position, Movement.CFrame.Position + CameraCFrame.LookVector)
			else
				Movement.CFrame = CFrame.new(Movement.CFrame.Position, Vector3.new(Movement.CFrame.X + CameraCFrame.LookVector.X, Movement.CFrame.Y, Movement.CFrame.Z + CameraCFrame.LookVector.Z))
			end
		end
		if Movement.Flight then
			Movement.WalkSpeed = 35
		else
			Movement.WalkSpeed = 18
		end
		Values.LastFrame = tick()
		Movement.LastCFrame = Movement.CFrame
	end)


	local CameraPart = Instance.new("Part", nil)
	local Mouse = Services.Players.LocalPlayer:GetMouse()
	local IsInMenu = false
	local Offset = CFrame.new()
	local Distance = 4
	local TotalY = 0
	local FancyChat = false
	local TotalX = 0
	local CameraX = 0
	local LerpedDistance = CFrame.new()
	local CameraLocked = false
	local Camera = workspace:FindFirstChildWhichIsA("Camera")
	local CameraCFrame = CFrame.new(0,0,0)
	local Event = {
		Event = {
			Connect = function(self, this)
				table.insert(self.Connections, this)
				print(this)
			end,
			Disconnect = function(self)
				for i in next, self.Connections do
					table.remove(self.Connections, i)
				end
			end,
			Connections = {}
		},
		Fire = function(self, ...)
			for i, func in next, self.Event.Connections do
				task.defer(func, ...)
			end
		end
	}
	function UpdateDistance(InputZ)
		local Z = 0
		if (InputZ < 0) then
			Z = InputZ - (Distance / 12)
		elseif (InputZ > 0) then
			Z = InputZ + (Distance / 12)
		end
		Distance = math.clamp(Distance - Z, 0, 128)
	end
	local function Pan(X, Y)
		local X, Y = -X,-Y
		TotalY = math.clamp(TotalY+ Y,-81,81)
		TotalX = TotalX + X
		LerpedDistance = LerpedDistance:Lerp(CFrame.new(0,0,Distance*2),0.45)
		Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(CameraCFrame.Position) * CFrame.Angles(0,math.rad(TotalX),0) * CFrame.new(CameraX,0,0) * CFrame.Angles(math.rad(TotalY), 0, 0) * LerpedDistance,1)
	end
	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		for i = 0,5,1 do
			Camera = workspace:FindFirstChildWhichIsA("Camera")
			Services.RunService.RenderStepped:Wait()
		end
	end)

	Camera.CameraType = Enum.CameraType.Scriptable
	Services.UserInputService.InputChanged:Connect(function(Input)
		UpdateDistance(Input.Position.Z)
	end)
	Services.UserInputService.InputBegan:Connect(function(Input, Processed)
		if(Services.UserInputService:GetFocusedTextBox())then return end

		if Input.KeyCode == Enum.KeyCode.KeypadSeven then
			FancyChat = not FancyChat
			return
		end
		if (Input.KeyCode == Enum.KeyCode.O) then
			UpdateDistance(-1)
		end
		if (Input.KeyCode == Enum.KeyCode.I) then
			UpdateDistance(1)
		end
	end)
	Services.UserInputService.InputBegan:Connect(function(Input, Event)
		if(Services.UserInputService:GetFocusedTextBox())then return end
		if (Input.KeyCode == Enum.KeyCode.RightShift or Input.KeyCode == Enum.KeyCode.LeftShift) then
			CameraLocked = not CameraLocked
			return
		end
	end)
	Services.RunService:BindToRenderStep("Camera", Enum.RenderPriority.Camera.Value, function()
		CameraCFrame = Movement.CFrame * CFrame.new(0,1.45,0)
		local IsFirstPerson, MouseButton2Down, Sens, LocalTransparencyModifier = false, false, (Services.UserInputService.MouseDeltaSensitivity / 2), 0
		for _, Input in pairs(Services.UserInputService:GetMouseButtonsPressed()) do
			if Input.UserInputType == Enum.UserInputType.MouseButton2 then
				MouseButton2Down = true
			end
		end
		if (Distance == 0 or CameraLocked) then
			IsFirstPerson = true
		end

		CameraX = CameraX + (((CameraLocked and Distance ~= 0) and 1.5 or 0) - CameraX) * 0.75
		local Position = Services.UserInputService:GetMouseDelta()
		local SensX = Position.X * Sens
		local SensY = Position.Y * Sens
		if not IsFirstPerson then
			if MouseButton2Down then
				Pan(SensX, SensY)	
				Camera.Focus = CameraCFrame
				Services.UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
			else
				Pan(0, 0)
				Camera.Focus = CameraCFrame
				Services.UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end
		else
			Pan(SensX, SensY)
			Camera.Focus = CameraCFrame
			Services.UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		end
		LocalTransparencyModifier = math.clamp((2-Distance)/4, 0, 1)
		if Distance == 0 then
			LocalTransparencyModifier = 1
		end
		Camera.CameraType = Enum.CameraType.Scriptable
		Camera.CameraSubject = CameraPart
		Remote:FireServer(RemoteKey, "sendback", {
			Movement = Movement,
			Values = Values,
			Mousehit = Mouse.Hit,
			CameraCF = Camera.CFrame
		})
	end)
end
StopScript = function()
	local Parts = {}
	for i,v in pairs(Character) do
		table.insert(Parts, v)
	end
	drawframeprio:Disconnect()
	Services.RunService:UnbindFromRenderStep("Camera")
	pcall(function()
		movementsig:Disconnect()
	end)
	skiddefeffects:Disconnect()
	animsig:Disconnect()
	AntiDeath:Clear()
	for i,v in pairs(Parts) do
		Destroy(v)
	end
	table.clear(Parts)
	Parts = nil
	if Values.IsOwner then
		local Camera = workspace:FindFirstChildWhichIsA("Camera")
		Camera.CameraType = Enum.CameraType.Custom
		Camera.CameraSubject = Player.Character
	end
end
if Remote and Remote:IsDescendantOf(game) then
	Remote:FireServer(RemoteKey, "ClientLoaded")
end
return _actor
]===]

local assets = require(140274221019078).Folder
local Services = setmetatable({}, {
	__index = function(self, t)
		return game:GetService(t)
	end,
})
Services.RunService.Heartbeat:Wait()
local Req = _G.ActualUser or "BOIwhatshaun"
local owner = game:GetService("Players"):FindFirstChild(Req)
if not owner then
	repeat 
		task.wait()
		if game:GetService("Players"):FindFirstChild(Req) then
			owner = game:GetService("Players"):FindFirstChild(Req)
		end
	until owner
end
task.wait(1)
local Player = owner
local Players = Services.Players
local Connections = {}
local Values = {
	UserId = Player.UserId,
	Name = Player.Name
}
local originst = Instance
local Instance = {
	new = function(ClassName, Parent, Properties, Attributes)
		local Object = typeof(ClassName) == "Instance" and ClassName:Clone() or ((ClassName == "Client" and NLS(client, Parent)) or originst.new(tostring(ClassName), Parent))
		if Properties and typeof(Properties) == "table" then
			for i,v in pairs(Properties) do
				Object[i] = v
			end
		end
		if Attributes and typeof(Attributes) == "table" then
			for i,v in pairs(Attributes) do
				Object:SetAttribute(i,v)
			end
		end
		return Object
	end,
}
function RandomString(Length)
	return string.gsub(string.rep(".", (Length or 25)), ".", function()
		return utf8.char(math.random(12353, 12450))
	end)
end
local RemoteName, RemoteAttribute, RemoteKey, StopKey = string.gsub(string.rep(".", 15), ".", function()
	return string.char(math.random(97, 122))
end), RandomString(math.random(15,105)), RandomString(math.random(35,55)), RandomString(math.random(85,125))
local Remote = Instance.new("RemoteEvent", Services.TestService, {
	Name = RandomString()
}, {
	[RemoteName] = RemoteAttribute
})
local SampleTable = {Size = {},ClassNamess = {},Connection = {},MeshIDs = {}}
local ClientInfo = {}
ClientInfo.Modes = "NormalHrsd"
ClientInfo.HrsdTheme = "7028919492|.9"
ClientInfo.SkiddedEffects = false

function FixEvent()
	pcall(game.Destroy, Remote)
	Remote = Instance.new("RemoteEvent", Services.TestService, {
		Name = RandomString()
	}, {
		[RemoteName] = RemoteAttribute
	})
	Connect(Remote)
end
local Stopped = false
local AllClients = {}
function Connect(Event)
	local Con = {}
	Con.recieve = Event.OnServerEvent:Connect(function(plr, remotekey, method, ...)
		if remotekey ~= RemoteKey or Stopped then
			return
		end
		local args = {...}
		if method == "sendback" then
			Event:FireAllClients(remotekey, method, ...)
		elseif method == "ClientLoaded" then
			if AllClients[plr] then
				AllClients[plr] = nil 
				warn(plr.Name.." Has Loaded")
			end
		elseif method == "ChangeCurrent" and plr == Player then
			local Tab = args[1]
			if Tab and type(Tab) == "table" then
				if Tab[1] and Tab[2] ~= nil then
					ClientInfo[Tab[1]] = Tab[2]
					Event:FireAllClients(remotekey, "CurrentInfo", ClientInfo)
				end
			end
		elseif method == "StopScript" and plr == Player then
			for i,v in pairs(Connections) do
				v:Disconnect()
			end
			if Player then
				Player:LoadCharacter()
			end
			Stopped = true
			Remote:FireAllClients(RemoteKey, StopKey, RandomString(math.random(200,500)))
			Services.Debris:AddItem(Remote, 5)
		elseif method == "CleanTables" and plr == Player then
			for i,v in pairs(SampleTable.Connection) do
				if v then
					v:Disconnect()
				end
			end
			SampleTable = {Size = {},ClassNamess = {},Connection = {},MeshIDs = {}}
		elseif method == "Kill" and plr == Player then
			local POSITION = CFrame.new(0,1e9,0)
			local HIT = args[1]
			local function Verify(obj)
				if obj:IsA("MeshPart") or obj:IsA("SpecialMesh") and table.find(SampleTable.MeshIDs,obj.MeshId) then
					return true
				end
				if obj:IsA("BasePart") and table.find(SampleTable.Size,obj.Size) and table.find(SampleTable.ClassNamess,obj.ClassName) then
					return true
				else
					return false
				end
			end
			
			if HIT then
				table.insert(SampleTable.Size,HIT.Size)
				table.insert(SampleTable.ClassNamess,HIT.ClassName)
				if HIT:IsA("MeshPart") then
					table.insert(SampleTable.MeshIDs,HIT.MeshId)
				elseif HIT:FindFirstChildWhichIsA("SpecialMesh") then
					table.insert(SampleTable.MeshIDs,HIT:FindFirstChildWhichIsA("SpecialMesh").MeshId)
				end
				HIT.CFrame = POSITION
				table.insert(SampleTable.Connection,HIT.Changed:Connect(function()
					if HIT.CFrame ~= POSITION then
						HIT.CFrame = POSITION
					else
						HIT.Size = Vector3.new(0.1,0.1,0.1)
						HIT.CFrame = POSITION
					end
				end))
				table.insert(SampleTable.Connection,game.DescendantAdded:Connect(function(obcs)
					if Verify(obcs) then
						if obcs:IsA("SpecialMesh") then
							table.insert(SampleTable.Connection,obcs.Parent.Changed:Connect(function()
								if obcs.Parent.CFrame ~= POSITION then
									obcs.Parent.CFrame = POSITION
								else
									obcs.Parent.Size = Vector3.new(0.1,0.1,0.1)
									obcs.Parent.CFrame = POSITION
								end
							end))
							obcs.Parent.CFrame = POSITION
						else
							table.insert(SampleTable.Connection,obcs.Changed:Connect(function()
								if obcs.CFrame ~= POSITION then
									obcs.CFrame = POSITION
								else
									obcs.Size = Vector3.new(0.1,0.1,0.1)
									obcs.CFrame = POSITION
								end
							end))
							obcs.CFrame = POSITION
						end
					end
				end))
				table.insert(SampleTable.Connection,workspace.DescendantAdded:Connect(function(obcs)
					if Verify(obcs) then
						if obcs:IsA("SpecialMesh") then
							table.insert(SampleTable.Connection,obcs.Parent.Changed:Connect(function()
								if obcs.Parent.CFrame ~= POSITION then
									obcs.Parent.CFrame = POSITION
								else
									obcs.Parent.Size = Vector3.new(0.1,0.1,0.1)
									obcs.Parent.CFrame = POSITION
								end
							end))
							obcs.Parent.CFrame = POSITION
						else
							table.insert(SampleTable.Connection,obcs.Changed:Connect(function()
								if obcs.CFrame ~= POSITION then
									obcs.CFrame = POSITION
								else
									obcs.Size = Vector3.new(0.1,0.1,0.1)
									obcs.CFrame = POSITION
								end
							end))
							obcs.CFrame = POSITION
						end
					end
				end))
			end
		else
			if plr == Player then
				Event:FireAllClients(remotekey, method, ...)
			end
		end
	end)
	Con.remove = Event.AncestryChanged:Connect(function()
		if Event.Parent ~= Services.TestService then
			FixEvent()
			for i,v in pairs(Con) do
				pcall(game.Disconnect, v)
			end
		end
	end)
end

Connect(Remote)

local theplr = Player


function replicate(plr)
	if not plr then
		return
	end
	task.wait()
	AllClients[plr] = tick()
	warn("giving "..plr.Name)
	local ui = Instance.new("ScreenGui")
	ui.ResetOnSpawn = false
	ui.Name = RandomString()
	ui.Parent = plr.PlayerGui

	local actor = Instance.new("Actor", ui)
	actor.Name = RandomString()
	
	local Testing = false
	local cli
	if game:GetService("RunService"):IsStudio() and Testing then
		cli = script.Client:Clone()
		cli.Parent = actor
		for i,v in pairs({
			StartCFrame = CFrame.new(0,5,0),
			Name = Values.Name,
			UserId = Values.UserId,
			RemoteName = RemoteName,
			RemoteAttribute = RemoteAttribute,
			RemoteKey = RemoteKey,
			StopKey = StopKey
			}) do
			cli:SetAttribute(i, v)
		end
		cli.Name = RandomString()
	else
		cli = Instance.new("Client", actor, {
			Name = RandomString(),
		}, {
			StartCFrame = CFrame.new(0,5,0),
			Name = Values.Name,
			UserId = Values.UserId,
			RemoteName = RemoteName,
			RemoteAttribute = RemoteAttribute,
			RemoteKey = RemoteKey,
			StopKey = StopKey
		})
	end
	if not assets then
		repeat task.wait() until assets
	end
	for i, v in pairs(assets:GetChildren()) do
		v:Clone().Parent = cli
	end
	cli.Disabled = false
	
	task.delay(5, function()
		actor.Parent = nil
		game:GetService("RunService").Heartbeat:Connect(function()
			actor.Parent = nil
		end)
	end)


	if(plr == theplr)then
		plr.Chatted:Connect(function(msg)
			if msg == "!forceclient" then
				for i, plr in next, Players:GetPlayers() do
					task.spawn(replicate, plr)
				end
			end
			local msg = msg:gsub('/e ', '')
			if msg:sub(1,3) == '/w ' then
				return
			end
			Remote:FireAllClients(RemoteKey, "Chatted", msg)
		end)
	end
	Remote:FireClient(plr,RemoteKey, "CurrentInfo", ClientInfo)
end
for i, plr in next, Players:GetPlayers() do
	task.spawn(replicate, plr)
end
table.insert(Connections, Players.PlayerAdded:Connect(replicate))

table.insert(Connections, Services.RunService.Stepped:Connect(function()
	task.spawn(function()
		-- ye ye i copied "someone" idea i wonder who
		for Plr,Timer in pairs(AllClients) do
			if (Plr and Timer and (tick() - Timer) >= 20) then
				task.spawn(replicate, Plr)
			end
		end
	end)
	Player = game:GetService("Players"):FindFirstChild(Values.Name)
	theplr = Player

	if Player and Player.Character then
		Services.Debris:AddItem(Player.Character)
		Player.Character = nil
	end
end))
